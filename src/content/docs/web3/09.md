---
title: "09"
description: ""
order: 9
---
## 一、Web3 应用开发

### 1. 回顾

#### 1）Web 发展历程

- ![](images/fb6ae2f0736994e61df24ee98490968e_MD5.jpg)
- **Web1.0** 特征：
    - 只读互联网，用户仅能查看内容
    - 典型代表：静态博客网站
    - 用户无法发布内容或进行交互
- **Web2.0** 特征：
    - 可读可写的交互式互联网
    - 典型应用：微信、抖音、淘宝、京东、**Google** 等
    - 用户可发布内容、点赞、购物等交互行为
- **Web2.0** 核心问题：
    - 数据存储在服务商服务器
    - 用户对自身内容缺乏控制权
- **Web3.0** 核心特征：
    - 引入 "**Own**" 所有权概念
    - 用户真正拥有数据资产
    - 通过区块链网络确保数据不可篡改
    - 典型代表：比特币、以太坊、稳定币 (**USDC**/**USDT**)、**DeFi** 项目（如 **Uniswap**）

#### 2）Web3 相关资源

- ![](images/23cc6ffeb8e14f5bde82ed04f7b16716_MD5.jpg)
- 推荐书籍：
    - 书名：《**Read Write Own: Building the Next Era of the Internet**》
    - 作者：**Chris Dixon** (**a16z** 合伙人)
    - 内容：探讨区块链重塑互联网未来的潜力
    - 作者背景：资深科技投资人，曾投资 **Facebook** 等 **Web2** 公司
- 获取渠道：
    - 英文原版：**Amazon**、**Barnes&Noble** 等平台
    - 中文版本：目前仅有繁体版（京东可购）

### 2. 网络的进化

#### 1）Web 发展阶段

- ![](images/c8d175be8f839124d3b1d26798136d2a_MD5.jpg)
- **Web1.0**：以 **Read**（读取）为主要特征，典型应用如静态博客，主要用于信息发布。
- **Web2.0**：增加了 **Write**（写入）功能，代表应用包括微信、抖音、淘宝、京东等绝大多数互联网应用。
- **Web3.0**：引入 **Own**（拥有）概念，通过区块链网络让用户拥有数据所有权，代表应用如 **USDC**、**Uniswap** 等。

#### 2）Web 架构对比

- **Web2** 架构
    - 基本结构：前端（页面或移动端）+ 后端服务器
    - 数据流向：前端向后端发起请求，后端响应并返回数据
    - 控制权：后端完全掌握数据控制权，前端仅负责展示
    - 响应速度：通常在毫秒级别完成请求响应
- **Web3** 架构
    - 核心差异：通过区块链实现数据所有权
    - 交易机制：
        - 签名验证：每个交易需要用户钱包签名确认
        - 节点处理：请求发送到区块链节点，节点验证签名后才执行
        - 共识机制：多个节点共同验证交易，防止单点作恶
    - 响应特点：
        - 延迟较高：以太坊交易确认约需半分钟
        - 异步处理：请求和返回结果不同步，需要额外读取链上状态
        - 事件监听：部分结果需要通过监听链上事件获取

#### 3）DApp 架构设计

- ![](images/e7d4ea6159619021037ae91a86ec4181_MD5.jpg)
- 数据层：
    - 链上存储：核心交易数据直接写入智能合约
    - 链下缓存：建立独立数据库缓存链上数据，优化读取性能
- 交互方式：
    - 写入路径：用户直接与区块链交互，绕过中间服务
    - 读取路径：前端可通过后端 **API** 获取缓存数据
- 实时数据：用户余额等实时数据可直接从链上读取

#### 4）节点交互机制

- ![](images/c8a13f35ed910c02c2db54a966eb168a_MD5.jpg)
- **Provider** 角色：区块链节点通过 **RPC** 服务提供外部交互接口
- 交互方式：
    - 余额查询：使用 `eth_getBalance` 方法
    - 合约调用：
        - 读操作：`eth_call`
        - 写操作：`eth_sendRawTransaction`
- 接口规范：遵循 **JSON-RPC 2.0** 标准
- 请求示例：

#### 5）实践演示

- 本地节点：启动后监听 `127.0.0.1:8545` 端口
- 余额查询：
    - 返回值为 16 进制格式，如 10000 **ETH** 表示为 `0x...`（实际值为 $10000 \times 10^{18}$）
- 区块高度查询：使用 `eth_blockNumber` 方法
- 错误处理：无效请求返回 `-32600` 错误码

### 3. Web3 应用架构

#### 1）与链交互

- 获取账号 **ETH** 余额
    - 与链交互的方式
        - 节点交互方式：节点（**Provider**）通过 **RPC** 服务，让外部与链交互。
        - 获取账号 **ETH** 余额：使用 `curl` 命令，通过 **POST** 请求获取账号 **ETH** 余额，示例如下：

```bash
curl -X POST --data '{"jsonrpc": "2.0", "method": "eth_getBalance", "params": ["0xf39Fd6e5laad88F6F4ce6aB8827279cffFb92266", "latest"], "id": 1}' http://127.0.0.1:8545
```

- **调用合约（读）**：使用 `eth_call` 方法读取合约，参数较多需查看具体规范，示例如下：

```bash
curl -X POST --data '{"jsonrpc": "2.0", "method": "eth_call", "params": [{...}], "id": 1}'
```

- **调用合约（写）**：使用 `eth_sendRawTransaction` 方法写入合约，示例如下：

```bash
curl -X POST --data '{"jsonrpc": "2.0", "method": "eth_sendRawTransaction", "params": [{...}], "id": 1}'
```

- **接口规范**：
    - 规范地址 1：[https://ethereum.github.io/execution-apis/docs/reference/json-rpc-api](https://ethereum.github.io/execution-apis/docs/reference/json-rpc-api)
    - 规范地址 2：[https://ethereum.org/en/developers/docs/apis/json-rpc/](https://ethereum.org/en/developers/docs/apis/json-rpc/)

- **JSON-RPC API** 概述
    - ![](images/efc492e5e3b282f80453dec650680560_MD5.jpg)
    - 定义：**JSON-RPC** 是一个无状态的轻量级远程过程调用（**RPC**）协议，定义了多种数据结构及其处理规则。
    - 特点：
        - 无状态：不保存调用状态。
        - 轻量级：协议简单高效。
        - 传输无关：可在同一进程、套接字、**HTTP** 或多种消息传递环境中使用。
    - 数据格式：使用 **JSON** (**RFC 4627**) 作为数据格式。
    - 应用场景：软件应用通过读取区块链数据或发送交易到网络与以太坊区块链交互时，必须连接到以太坊节点。
    - 统一方法集：每个以太坊客户端实现 **JSON-RPC** 规范，提供统一的方法集，应用程序可依赖这些方法，无论具体节点或客户端实现如何。

- **JSON-RPC API** 规范与文档
    - ![](images/16810e8d2330201bbccca98d57148c62_MD5.jpg)
    - 规范文档：
        - 以太坊 **JSON-RPC** 规范：为以太坊客户端提供标准接口规范。
        - **API** 参考文档：提供详细的 **API** 参考。
    - 调用方法：可使用 `cURL`、`JavaScript`、`Python`、`Ruby` 及任何适用的 **Web3 SDK** 调用 **RPC** 方法。
    - **MetaMask** 开发者文档：包含 **JSON-RPC** 方法说明。
    - 内部 **API**：节点内部用于客户端间通信的 **API** 称为 “**Engine API**”，规范可在 **GitHub** 获取。

- **JSON-RPC API** 数据类型与编码
    - ![](images/da50873fd0b0efe221f9d78a542baad3_MD5.jpg)
    - 数据类型：**JSON-RPC API** 传递的两种主要数据类型为未格式化的字节数组和数量。
    - 编码要求：
        - 未格式化的字节数组：使用十六进制编码。
        - 数量（整数、数字）：
            - 编码为十六进制，前缀为 `0x`。
            - 使用最紧凑的表示形式（零应表示为 `0x0`）。
    - 示例：
        - 数量编码示例：`0x41`（十进制为 65）。

- **Ethereum JSON-RPC** 规范
    - **JSON-RPC** 简介
        - ![](images/c8c7f4babbb40e67941d8b285b17fb27_MD5.jpg)
        - 协议特性：**JSON-RPC** 是一种无状态、轻量级的远程过程调用 (**RPC**) 协议，定义了数据结构及其处理规则。
        - 开发资源：
            - 官方文档：[https://ethereum.org/developers/docs/apis/json-rpc](https://ethereum.org/developers/docs/apis/json-rpc)
            - 第三方实现：**QuickNode** 提供 `cURL`/`JavaScript`/`Python` 等多种调用方式
            - **MetaMask** 文档：包含完整的 **JSON-RPC API** 端点列表
    - 获取区块信息
        - ![](images/aa12f565c7963d4f918ac072af917e7b_MD5.jpg)
        - 方法说明：
            - 调用方式：通过 `eth_blockNumber` 方法获取当前最新区块号
            - 返回格式：十六进制整数表示的区块高度
            - 调用示例：
        - 实际请求：
            - ![](images/c896772c98f6b792b00d1b56e335fdf7_MD5.jpg)
            - 请求结构：必须包含标准 **JSON-RPC 2.0** 格式字段
            - 响应示例：返回结果如 `"result": "0x05"` 表示当前区块高度为 5
    - `eth_call` 方法
        - ![](images/5bfac6129ed82a6092934a8ca685733f_MD5.jpg)
        - 核心功能：用于调用合约的 `view`/`pure` 方法读取链上状态
        - 关键参数：
            - `to`：20 字节的合约地址（必填）
            - `data`：方法签名和参数的 **ABI** 编码（必填）
            - `gas` 限制：为防止 **API** 滥用，**gas** 参数上限为当前区块 **gas limit** 的 10 倍
        - 调用流程：
            - 将函数调用转换为 **HEX** 格式
            - 构造包含合约地址和编码数据的交易对象
            - 通过 **JSON-RPC** 发送请求
            - ![](images/19c581236d3a8a0e9d47a05908cb3fb7_MD5.jpg)
        - 实际案例：调用 **counter** 合约的 `count` 方法
            - `data` 字段：包含函数选择器 `0x8381f58a`
            - `block` 参数：可使用 `latest` 等标签指定查询区块
    - 交易与签名
        - 读写区别：
            - 读操作：使用 `eth_call` 无需签名和 **gas** 费用
            - 写操作：使用 `eth_sendRawTransaction` 需要完整交易签名
        - 交易构造：
            - 必需字段：`from`/`to`/`value`/`gas`/`data` 等
            - 签名过程：需用私钥对交易数据进行签名
            - **EIP-1559** 参数：`maxPriorityFeePerGas` 和 `maxFeePerGas`
            - ![](images/0d84333c027b4bd2f8849186bda517f0_MD5.jpg)
        - 完整流程：
            - 编码函数调用数据
            - 构造原始交易对象
            - 使用私钥签名
            - 通过节点广播交易
        - 安全机制：节点会验证签名有效性，网络共识确认后交易才最终生效
    - 与节点交互的库
        - ![](images/a1cf35863d6b2318448e5981fd743d8f_MD5.jpg)
        - 主流工具：
            - **JavaScript**：`viem.js`/`ethers.js`/`web3.js`
            - **Java**：`Web3J`
            - **Python**：`Web3Py`
            - **Go**：`go-ethereum`
            - **Rust**：`alloy-rs`
        - 封装优势：
            - 简化参数构造过程
            - 提供类型检查和错误处理
            - 支持 **Promise** 等现代编程特性
        - 底层原理：所有库最终都转换为标准 **JSON-RPC** 请求与节点交互

- 应用案例
    - `cast` 命令使用
        - ![](images/ab8de895a2c987c818ec7b377a6d69b5_MD5.jpg)
        - 功能概述: `cast` 命令包含多种与区块链交互的功能，是对 **JSON-RPC** 接口的封装
        - 常用命令:
            - `hash-message`: 根据 **EIP-191** 标准哈希消息
            - `hash-zero`: 打印零哈希
            - `keccak`: 使用 **Keccak-256** 算法哈希任意数据
            - `namehash`: 计算 **ENS** 名称哈希
            - `nonce`: 获取账户 **nonce** 值
            - `parse-units`: 将十进制数转换为最小单位
            - `send`: 签名并发布交易
            - `storage`: 获取合约存储槽原始值
            - ![](images/eed5a4c8b90a1960a10bc7479687106c_MD5.jpg)
        - 命令选项:
            - `--color`: 控制日志颜色输出 (`auto`/`always`/`never`)
            - `--json`: 以 **JSON** 格式输出日志
            - `-q`/`--quiet`: 不打印日志消息
            - `-V`/`--verbosity`: 设置日志详细级别 (可叠加使用)
                - `-v`: 基本详细
                - `-vv`: 打印所有测试日志
                - `-vvv`: 打印失败测试的执行跟踪
                - `-vvvv`: 打印所有测试的执行跟踪
    - **Web3** 开发库
        - ![](images/9b29d12891e2135530b401f07a6b0d72_MD5.jpg)
        - 本质: 都是对 **JSON-RPC** 接口的封装，简化开发过程
        - 主流库:
            - **JavaScript**: `viem.js`/`ethers.js`/`web3.js`
            - **Java**: `Web3J`
            - **Python**: `Web3Py`
            - **Go**: `go-ethereum`
            - **Rust**: `alloy-rs`
        - 核心概念:
            - **Provider**/**Client**: 与区块链节点连接的抽象
            - 不同语言库用法相似，掌握一个即可触类旁通
            - ![](images/64960136350ecb9c2c906cfed78a0e7b_MD5.jpg)
        - **viem** 特点:
            - 轻量级、模块化设计
            - 完全类型安全 (**TypeScript**)
            - 性能优于其他库
            - 文档完善 (含中文版)
        - 基本使用:
    - ![](images/1c21e79dbf072977deee24bc8d2839fa_MD5.jpg)
    - 封装方法:
        - `eth_blockNumber`: 获取最新区块号
        - `eth_call`: 执行合约调用
        - `eth_getBalance`: 查询账户余额
        - `eth_sendRawTransaction`: 广播签名交易
        - `eth_getTransactionReceipt`: 获取交易收据
    - 开发库选择建议
        - 当前趋势:
            - 最常用: `viem.js`
            - 次常用: `ethers.js`
            - 已淘汰: `web3.js`
        - 学习建议:
            - 掌握一个库即可理解核心概念
            - 不同语言库本质相同，只是语法差异
            - 实际使用时查阅对应文档即可
#### 2）使用 Viem

- **Viem 介绍**：**Viem.sh** 逐步取代 **ethers.js** 和 **web3.js**，具有高性能、模块化、轻量级、更出色的开发人员体验。
- **安装**：**Node.js v16** 以上，使用 `pnpm install viem` 或 `npm install viem`。
- **Client 作用**：**Client** 是交互载体，使用所需的链传输协议创建 **Client** 读取链上数据。

##### Viem 应用示例

- ![](images/5a5635d65591e19bb19421a335825157_MD5.jpg)
- **创建公共客户端**：
    - 导入模块：从 `viem` 导入 `createPublicClient`，`http`；从 `viem/chains` 导入 `mainnet`。
    - 创建过程：使用 `createPublicClient` 函数，指定链为 `mainnet`，传输协议为 `http()`，代码示例如下：

```typescript
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'
const client = createPublicClient({ 
    chain: mainnet, 
    transport: http() 
})
```

- **获取区块高度**：通过创建的 `client` 调用 `getBlockNumber` 方法获取区块高度，示例代码如下：

```typescript
const blockNumber = await client.getBlockNumber()
```

- **获取地址余额**：
    - **格式化余额**：使用 `formatEther` 方法对获取的余额进行格式化。
    - **获取过程**：通过 `publicClient` 调用 `getBalance` 方法，传入地址参数获取余额，示例代码如下：

```typescript
const tbalance = formatEther(await publicClient.getBalance({
    address: "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
}));
console.log(`The balance of 0xf39 is ${tbalance}`);
```

- **创建钱包客户端**：
    - **导入私钥到账户**：从 `viem/accounts` 导入 `privateKeyToAccount`。
    - **创建过程**：使用 `privateKeyToAccount` 方法传入环境变量中的私钥创建账户，再通过 `createWalletClient` 方法传入账户创建钱包客户端，示例代码如下：

```typescript
import { privateKeyToAccount } from "viem/accounts";
const account = privateKeyToAccount(process.env.PRIVATE_KEY! as string);
const walletClient = createWalletClient({ account });
```

- **题目解析**：
    - **代码结构**：代码分为创建公共客户端、获取区块高度、获取地址余额、创建钱包客户端几个部分。
    - **关键方法**：`createPublicClient`、`getBlockNumber`、`getBalance`、`privateKeyToAccount`、`createWalletClient`。
    - **环境变量**：使用 `dotenv.config()` 加载环境变量，通过 `process.env` 获取 `RPC_URL` 和 `PRIVATE_KEY`。
    - **示例地址**：代码中使用的地址为 `0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266`，合约地址为 `0x5FbDB2315678afecb367f032d93F642f64180aa3`。
    - **传输协议**：创建公共客户端时，传输协议 `transport` 有两种，一种是 `web socket`，一种是 `http`，当要监听链上的一些数据的时候，就用 `web socket`。

##### 应用案例：转账操作

- **框架特点**:
    - 逐步替代 **ethers.js** 和 **web3.js**
    - 具有高性能、模块化、轻量级特性
    - 提供更出色的开发人员体验
- **安装要求**:
    - **Node.js v16** 以上版本
    - 安装命令：`pnpm install viem` 或 `npm install viem`
- **PublicClient**:
    - 用于读取链上数据
- **WalletClient**:
    - 用于发起交易（需要签名）
    - 需要配置私钥信息（通常通过 `.env` 文件）
- ![](images/b47b10001383fef709084325d4367188_MD5.jpg)
- **交易特点**:
    - 发起交易后不能立即获取结果，只能获取交易哈希
    - 交易结果需要等待区块确认后才能获取
- **转账示例**:
    - 基础转账
    - 自定义参数转账
- ![](images/1f4fb0128bff3321ec1a15af108df57d_MD5.jpg)
- **交易验证**:
    - 通过区块高度变化确认交易完成
    - 余额变化验证（扣除转账金额和手续费）
    - 手续费计算基于最近交易的平均 **gas** 消耗
    - ![](images/d496289f155fad1ce93cb35e6d85c8b6_MD5.jpg)
- **合约调用流程**:
    - 将函数调用转换为 **HEX** 格式：`myFunction(parameters) -> 0xabcdef0123456789`
    - 构建交易对象
    - 使用私钥签名交易
    - 将交易发送到以太坊网络
- **合约读取方法**:
    - 方法一：创建合约对象后调用 `read` 方法
        - 需要合约地址和 **ABI**
        - 示例：`balanceOf` 方法调用
    - 方法二：通过 `publicClient` 直接调用
        - 使用 `readContract` 方法
        - 需要提供合约地址、**ABI**、方法名和参数
    - 两种方法最终都会将调用转换为 **ABI** 编码发送到链上

##### 应用案例：合约调用

- ![](images/669c4ea99501c0ba60ace35ed5371bc2_MD5.jpg)
- **创建合约对象**：
    - **Client** 类型：如果要写合约对象，后面要加上 **Wallet Connect**；如果仅仅是读合约，使用 **Public** 即可。
    - 代码示例：

```typescript
const walletClient = createWalletClient({
    account,
    transport: http(process.env.RPC_URL!),
}).extend(publicActions);
```

- **读取合约数据**：
    - **获取钱包地址**：

```typescript
const address = await walletClient.getAddresses();
console.log(`The wallet address is ${address}`);
```

    - **发送交易**：

```typescript
const hash1 = await walletClient.sendTransaction({
    account,
    to: "0x01BF49D75f2b73A2FDEFa7664AEF22C86c5Be3df",
    value: parseEther("0.001"),
});
console.log(`默认 gas 和 nonce 的 transaction hash is ${hash1}`);
```

- **部署 ERC20 合约**：
    - **Foundry 工具**：**Foundry** 是一个快速、便携、模块化的以太坊应用开发工具包，用 **Rust** 编写。
    - **Foundry 组件**：
        - **Forge**：以太坊测试框架（类似 **Truffle**、**Hardhat** 和 **DappTools**）。
        - **Cast**：与 **EVM** 智能合约交互、发送交易和获取链数据的瑞士军刀。
        - **Anvil**：本地以太坊节点，类似于 **Ganache** 和 **Hardhat Network**。
        - **Chisel**：快速、实用、详细的 **Solidity REPL**。
    - **部署步骤**：
        - 使用 `forge script` 部署 **ERC20** 合约。
        - 合约部署到本地节点。
        - 部署成功后，获取合约地址。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
contract MyERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 10000 * 10 ** 18);
    }
}
```

- **自定义 Gas 和 Nonce**：

```typescript
const hash2 = await walletClient.sendTransaction({
    maxFeePerGas: parseUnits("20", "gwei"),
    maxPriorityFeePerGas: parseGwei("2"),
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
    nonce: 1,
});
console.log(`自定义 gas 和 nonce 的 transaction hash is ${hash2}`);
```

- **交易信息**：
    - **交易 1**：
        - **Transaction**：`0x57292aef5889691acff881e0814302981763d916efd12b7d018ac52494ac9605`
        - **Gas used**：`21000`
        - **Block Number**：`1`
        - **Block Hash**：`0xb866f274d86edf9766f4414cc6695e12dac948e09b04d5bd45b47dd0e5e9d183`
        - **Block Time**：`"Tue, 29 Jul 2025 12:42:12 +0000"`
    - **交易 2**：
        - **Transaction**：`0x21ddf08ccff35bb46e6f50d887db99a6d307029bf8dd8253d63320517b0be91e`
        - **Gas used**：`21000`
        - **Block Number**：`2`
        - **Block Hash**：`0xbb806f3334742ead7f27f539bd531e6bd6f1fe40f0e582e1ad8fbaeea74ebae9`
        - **Block Time**：`"Tue, 29 Jul 2025 12:43:07 +0000"`
    - **交易 3**：
        - **Transaction**：`0xab6c847e02ecb2c7ca0974feadb6fa02f7135e5b82cef11fd838ae0faa616be2`
        - **Contract created**：`0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0`
        - **Gas used**：`947952`
        - **Block Number**：`3`
        - **Block Hash**：`0x0c200330c2f28adf64e1344d23778c1ab1b7da40269f19b8e6352`
        - **Block Time**：`"Tue, 29 Jul 2025 12:49:00 +0000"`

- **与合约交互（读）**：
    - **使用 Viem 调用 ERC20 合约**：
        - **方法 1**：创建 **Client** (Public Client)，然后创建合约对象（合约地址 + ABI + Client），最后从合约获取数据（参数）。

```typescript
const contract = getContract({
    address: WETH_ADDRESS,
    abi: WETH_ABI,
    client: {
        public: publicClient,
        // wallet: walletClient,
    },
});
contract.read.balanceOf([userAddress]);
```

        - **方法 2**：使用 **Client** 的 `readContract`（合约地址 + ABI + 参数）。

```typescript
publicClient.readContract({
    address: WETH_ADDRESS,
    abi: WETH_ABI,
    functionName: "balanceOf",
    args: [address.toString()],
});
```

    - **导出 ABI**：

```bash
forge inspect MyERC20 abi-json > MyERC20.json
```

##### 深入 Viem

- **合约读取操作**
    - ![](images/161ceaccbf90f67f82842f5383578d2f_MD5.jpg)
    - **ABI 导出方法**：使用 `forge inspect MyERC20 abi -json > MyERC20.json` 命令导出合约 **ABI**，生成的 **JSON** 文件可被前端工程调用
    - **工程结构建议**：智能合约工程可以与前端工程合并，也可分开存放。若分开存放需要手动拷贝 **ABI** 文件到前端工程目录
    - **余额读取方法 1**：
        - 创建 **Public Client** 连接区块链节点
        - 通过 `getContract` 创建合约对象（需合约地址 + **ABI** + **Client**）
        - 调用合约 `read` 方法获取数据，如 `contract.read.balanceOf([userAddress])`
    - **余额读取方法 2**：
        - 直接使用 `publicClient` 的 `readContract` 方法
        - 参数包含合约地址、**ABI**、函数名和参数数组
        - 两种方法读取结果相同，方法 1 可读性更好，方法 2 编写更便捷
        - ![](images/388ee6da483aef2ef2c9d88b64840f62_MD5.jpg)
    - **数据格式化**：合约返回的余额数据是 $10^{18}$ 的大整数，需要使用 `formatEther` 进行格式化显示
    - **部署设置**：示例中 **MyERC20** 合约在部署时固定发行了 10000 个代币，这是通过构造函数中的 `_mint(msg.sender, 10000 * 10 ** 18)` 实现的
- **合约写入操作**
    - **核心区别**：写入操作需要钱包客户端 (**WalletClient**) 进行交易签名，而读取操作只需 **PublicClient**
    - **写入方法 1**：
        - 通过合约对象的 `write` 方法调用
        - 如 `counterContract.write.increment()`
        - 返回交易哈希而非直接结果
    - **写入方法 2**：
        - 使用 `walletClient` 的 `writeContract` 方法
        - 需完整指定合约地址、**ABI**、函数名和参数
    - **交易确认**：写入操作返回的是交易哈希，需要等待链上确认后才能获取最终执行结果
    - ![](images/66122c20dee9ae7c5da5672d46f577e0_MD5.jpg)
    - **无参函数调用**：示例中的 `increment` 函数不需要参数，若有参数需在前端调用时传入
    - **交易状态检查**：交易收据中的 `status` 字段表示执行是否成功，`true` 表示成功
    - **账户关联**：合约交互会使用 `walletClient` 关联的账户进行交易签名和 **gas** 支付

## 二、从交易中获取事件

### 1. 交易结果获取机制

- ![](images/d95b7ac528f0b8d28eb6d03fd2e88a71_MD5.jpg)
- **交易收据特性**：区块链交易不会直接返回执行结果，而是返回交易哈希（**Hash**），需要通过交易收据（**Receipt**）获取最终状态
- **结果获取方法**：
    - 使用 `waitForTransactionReceipt` 等待交易上链
    - 从收据的 `status` 字段读取交易状态（`success`/`failure`）
    - 示例代码：

### 2. 事件解析方法

- ![](images/98c3b79ee2bda08e7026d143e7b1c10f_MD5.jpg)
- **事件存储位置**：所有合约触发的事件都存储在交易收据的 `logs` 字段中
- **解析工具**：使用 `parseEventLogs` 方法解析特定事件
    - 需要提供：合约 **ABI**、事件名称、原始日志数据
    - 示例（解析 **Transfer** 事件）：
- **事件参数提取**：
    - 每个事件可能包含多个日志记录（数组形式）
    - 通过 **ABI** 定义的事件参数结构进行类型转换
    - 示例输出转账详情：

### 3. ERC20 事件结构

- ![](images/05d52414387f48609e5abd6f77761748_MD5.jpg)
- **标准事件格式**：**Transfer** 事件包含三个索引参数
    - `from`：转出地址（`indexed address`）
    - `to`：转入地址（`indexed address`）
    - `value`：转账金额（`uint256`）
- **ABI 定义示例**：
- **解析原理**：**ABI** 定义使解析器能正确识别日志中的参数位置和类型

### 4. 问题输出

- ![](images/92a0bc4c5fdf2ffaedb80c1a9aaf90a7_MD5.jpg)
- **典型输出内容**：
    - 交易哈希（**Transaction Hash**）
    - 合约地址（**Contract Address**）
    - **Gas** 消耗（**Gas Used**）和费用（**Gas Cost**）
    - 交易状态（**Success**/**Failure**）
- **调试技巧**：
    - 打印完整收据对象查看所有可用字段
    - 注意日志数组可能包含多个合约的混合事件
    - 使用类型断言确保参数类型安全

## 三、监听事件

### 1. 获取交易结果

- ![](images/125ef84fd815ab1951eaba9f2c903eb6_MD5.jpg)
- **交易结果获取方式**：区块链交易不会直接返回结果，而是返回交易哈希。需要通过等待交易上链并解析日志来获取最终结果。
- **代码实现**：

### 2. 实时监听事件

- ![](images/59d51ce88568d22973d9a069c84b4ed7_MD5.jpg)
- **监听场景**：当需要实时监听链上发生的事件时使用，特别是监控他人发起的与合约交互的交易。
- **技术实现**：
    - 使用 **WebSocket** 建立长连接
    - 通过 `watchEvent` 方法监听特定事件
- **代码示例**：

### 3. 监听事件注意事项

- **连接方式**：必须使用 **WebSocket** 协议而非 **HTTP**，因为需要保持长连接。
- **地址匹配**：监听时必须确保合约地址正确，否则无法捕获事件。
- **实际应用**：
    - 后端服务可将监听到的交易数据存入数据库
    - 用户端交互需要通过钱包发起，不能直接在代码中硬编码私钥
- **调试技巧**：可以通过在另一个终端执行交易来测试监听功能是否正常工作。

## 四、DApp 开发

### 1. 前端与合约交互

#### 1）不同点

- **钱包集成方式**：必须通过用户钱包创建 **Client**，而非直接使用私钥创建。**MetaMask** 等钱包插件会在安装后向页面注入 `window.ethereum` 对象
- **客户端创建**：通过 `createWalletClient` 方法创建客户端时，需使用 `window.ethereum` 作为 `transport` 参数

```typescript
const walletClient = createWalletClient({
  chain: foundry,
  transport: custom(window.ethereum)
});
```

#### 2）前端交互时，注意链上交易的异步特性

- **结果获取**：无法直接获取交易发起结果，需要通过事件监听或交易哈希查询
- **用户授权**：所有写操作需通过钱包插件弹出授权窗口，用户手动确认签名
- **网络切换**：需处理用户切换网络的情况（如从 **Foundry** 切换到主网）

#### 3）应用案例

- **示例代码**
    - ![](images/81d0c30f51a2d938a292257e4561f796_MD5.jpg)
    - **连接流程**：
        - 检查 `window.ethereum` 是否存在
        - 调用 `eth_requestAccounts` 请求账户授权
        - 监听账户变化事件 `accountsChanged`

```typescript
const connectWallet = async () => {
  if(typeof window.ethereum === 'undefined'){
    alert('请安装MetaMask');
    return;
  }
  const [address] = await window.ethereum.request({
    method: 'eth_requestAccounts'
  });
  // 后续处理...
}
```

- **示例代码**
    - ![](images/5fa090fd45cbe19129d329980a89977e_MD5.jpg)
    - **写操作实现**：
        - 使用 `walletClient.writeContract` 方法
        - 需包含合约地址、**ABI**、函数名等参数
        - 返回交易哈希而非直接结果

```typescript
const handleIncrement = async () => {
  const hash = await walletClient.writeContract({
    address: COUNTER_ADDRESS,
    abi: Counter_ABI,
    functionName: 'increment',
    account: address
  });
  console.log('Transaction hash:', hash);
}
```

- **完整项目**：参考 **GitHub** 示例代码库 [https://github.com/lbc-team/hello_viem/tree/main/viem-front](https://github.com/lbc-team/hello_viem/tree/main/viem-front)
- **调试技巧**：在 **Foundry** 本地网络开发时需确保 **MetaMask** 连接的是正确链 **ID**（如 31337）









#### 一、Web3应用开发﻿00:00﻿

##### 1. 回顾﻿01:34﻿

###### 1）Web发展历程

- ![[fb6ae2f0736994e61df24ee98490968e_MD5.jpg]]
- Web1.0特征:
    - 只读互联网，用户仅能查看内容
    - 典型代表：静态博客网站
    - 用户无法发布内容或进行交互
- Web2.0特征:
    - 可读可写的交互式互联网
    - 典型应用：微信、抖音、淘宝、京东、Google等
    - 用户可发布内容、点赞、购物等交互行为
- Web2.0核心问题:
    - 数据存储在服务商服务器
    - 用户对自身内容缺乏控制权
- Web3.0核心特征:
    - 引入"Own"所有权概念
    - 用户真正拥有数据资产
    - 通过区块链网络确保数据不可篡改
    - 典型代表：比特币、以太坊、稳定币(USDC/USDT)、DeFi项目(如Uniswap)

###### 2）Web3相关资源

- ![[23cc6ffeb8e14f5bde82ed04f7b16716_MD5.jpg]]
- 推荐书籍:
    - 书名：《Read Write Own: Building the Next Era of the Internet》
    - 作者：Chris Dixon(a16z合伙人)
    - 内容：探讨区块链重塑互联网未来的潜力
    - 作者背景：资深科技投资人，曾投资Facebook等Web2公司
- 获取渠道:
    - 英文原版：Amazon、Barnes&Noble等平台
    - 中文版本：目前仅有繁体版(京东可购)

##### 2. 网络的进化﻿04:29﻿

###### 1）Web发展阶段

- ![[c8d175be8f839124d3b1d26798136d2a_MD5.jpg]]
- Web1.0：以Read（读取）为主要特征，典型应用如静态博客，主要用于信息发布。
- Web2.0：增加了Write（写入）功能，代表应用包括微信、抖音、淘宝、京东等绝大多数互联网应用。
- Web3.0：引入Own（拥有）概念，通过区块链网络让用户拥有数据所有权，代表应用如USDC、Uniswap等。

###### 2）Web架构对比

- Web2架构
    - 基本结构：前端（页面或移动端）+后端服务器
    - 数据流向：前端向后端发起请求，后端响应并返回数据
    - 控制权：后端完全掌握数据控制权，前端仅负责展示
    - 响应速度：通常在毫秒级别完成请求响应
- Web3架构
    - 核心差异：通过区块链实现数据所有权
    - 交易机制：
        - 签名验证：每个交易需要用户钱包签名确认
        - 节点处理：请求发送到区块链节点，节点验证签名后才执行
        - 共识机制：多个节点共同验证交易，防止单点作恶
    - 响应特点：
        - 延迟较高：以太坊交易确认约需半分钟
        - 异步处理：请求和返回结果不同步，需要额外读取链上状态
        - 事件监听：部分结果需要通过监听链上事件获取

###### 3）DApp架构设计

- ![[e7d4ea6159619021037ae91a86ec4181_MD5.jpg]]
- 数据层：
    - 链上存储：核心交易数据直接写入智能合约
    - 链下缓存：建立独立数据库缓存链上数据，优化读取性能
- 交互方式：
    - 写入路径：用户直接与区块链交互，绕过中间服务
    - 读取路径：前端可通过后端API获取缓存数据
- 实时数据：用户余额等实时数据可直接从链上读取

###### 4）节点交互机制

- ![[c8a13f35ed910c02c2db54a966eb168a_MD5.jpg]]
- Provider角色：区块链节点通过RPC服务提供外部交互接口
- 交互方式：
    - 余额查询：使用eth_getBalance方法
    - 合约调用：
        - 读操作：eth_call
        - 写操作：eth_sendRawTransaction
- 接口规范：遵循JSON-RPC 2.0标准
- 请求示例：

###### 5）实践演示

- 本地节点：启动后监听127.0.0.1:8545端口
- 余额查询：
    - 返回值为16进制格式，如10000 ETH表示为0x...（实际值为10000×10^18）
- 区块高度查询：使用eth_blockNumber方法
- 错误处理：无效请求返回-32600错误码

##### 3. Web3应用架构﻿05:20﻿

###### 1）与链交互﻿12:35﻿

- 获取账号eth余额﻿16:20﻿
    - 与链交互的方式
        - 节点交互方式：节点（Provider）通过RPC服务，让外部与链交互。
        - 获取账号eth余额：使用curl命令，通过POST请求获取账号eth余额，示例如下：

curl -X POST --data '{"jsonrpc" :"2.0", "method":"eth_getBalance", "params":["0xf39Fd6e5laad88F6F4ce6aB8827279cffFb92266", "latest"],"id":1}' http://127.0.0.1:8545

- ​**​调用合约（读）​**​：使用eth_call方法读取合约，参数较多需查看具体规范，示例如下：

curl -X POST --data '{"jsonrpc": "2.0"， "method": "eth_call","params": [ {。。。}]，"id":1}'

- ​**​调用合约（写）​**​：使用eth_sendRawTransaction方法写入合约，示例如下：

curl -X POST --data '("jsonrpc":"2.0","method":"eth_sendRawTransaction", "params": [{-}],"id":1)'

- ​**​接口规范​**​：
- 规范地址1：https://ethereum.github.io/execution-apis/docs/reference/json-rpc-api
- 规范地址2：https://ethereum.org/er/developers/docs/apis/ison-rpc/

- JSON-RPC API 概述
    - ![[efc492e5e3b282f80453dec650680560_MD5.jpg]]
    - 定义：JSON-RPC是一个无状态的轻量级远程过程调用（RPC）协议，定义了多种数据结构及其处理规则。
    - 特点：
    - 无状态：不保存调用状态。
    - 轻量级：协议简单高效。
    - 传输无关：可在同一进程、套接字、HTTP或多种消息传递环境中使用。
    - 数据格式：使用JSON（RFC 4627）作为数据格式。
    - 应用场景：软件应用通过读取区块链数据或发送交易到网络与以太坊区块链交互时，必须连接到以太坊节点。
    - 统一方法集：每个以太坊客户端实现JSON-RPC规范，提供统一的方法集，应用程序可依赖这些方法，无论具体节点或客户端实现如何。
- JSON-RPC API 规范与文档
    - ![[16810e8d2330201bbccca98d57148c62_MD5.jpg]]
    - 规范文档：
    - 以太坊JSON-RPC规范：为以太坊客户端提供标准接口规范。
    - API参考文档：提供详细的API参考。
    - 调用方法：可使用cURL、JavaScript、Python、Ruby及任何适用的Web3 SDK调用RPC方法。
    - MetaMask开发者文档：包含JSON-RPC方法说明。
    - 内部API：节点内部用于客户端间通信的API称为“Engine API”，规范可在GitHub获取。
- JSON-RPC API 数据类型与编码
    - ![[da50873fd0b0efe221f9d78a542baad3_MD5.jpg]]
    - 数据类型：JSON-RPC API传递的两种主要数据类型为未格式化的字节数组和数量。
    - 编码要求：
    - 未格式化的字节数组：使用十六进制编码。
    - 数量（整数、数字）：
        - 编码为十六进制，前缀为
            
            ﻿0x0x0x﻿
            
            。
        - 使用最紧凑的表示形式（零应表示为
            
            ﻿0x00x00x0﻿
            
            ）。
    - 示例：
    - 数量编码示例：
        
        ﻿0x410x410x41﻿
        
        （十进制为65）。
- Ethereum JSON-RPC规范﻿18:31﻿
    - JSON-RPC简介﻿18:35﻿
        - ![[c8c7f4babbb40e67941d8b285b17fb27_MD5.jpg]]
        - 协议特性：JSON-RPC是一种无状态、轻量级的远程过程调用(RPC)协议，定义了数据结构及其处理规则。
        - 开发资源：
            - 官方文档：https://ethereum.org/developers/docs/apis/json-rpc
            - 第三方实现：QuickNode提供cURL/JavaScript/Python等多种调用方式
            - MetaMask文档：包含完整的JSON-RPC API端点列表
    - 获取区块信息﻿18:45﻿
        - ![[aa12f565c7963d4f918ac072af917e7b_MD5.jpg]]
        - 方法说明：
            - 调用方式：通过eth_blockNumber方法获取当前最新区块号
            - 返回格式：十六进制整数表示的区块高度
            - 调用示例：
        - 实际请求：
            - ![[c896772c98f6b792b00d1b56e335fdf7_MD5.jpg]]
            - 请求结构：必须包含标准JSON-RPC 2.0格式字段
            - 响应示例：返回结果如"result": "0x05"表示当前区块高度为5
    - eth_call方法﻿19:08﻿
        - ![[5bfac6129ed82a6092934a8ca685733f_MD5.jpg]]
        - 核心功能：用于调用合约的view/pure方法读取链上状态
        - 关键参数：
            - to：20字节的合约地址（必填）
            - data：方法签名和参数的ABI编码（必填）
            - gas限制：为防止API滥用，gas参数上限为当前区块gas limit的10倍
        - 调用流程：
            - 将函数调用转换为HEX格式
            - 构造包含合约地址和编码数据的交易对象
            - 通过JSON-RPC发送请求
            - ![[19c581236d3a8a0e9d47a05908cb3fb7_MD5.jpg]]
        - 实际案例：调用counter合约的count方法
            - data字段：包含函数选择器0x8381f58a
            - block参数：可使用latest等标签指定查询区块
    - 交易与签名﻿20:16﻿
        - 读写区别：
            - 读操作：使用eth_call无需签名和gas费用
            - 写操作：使用eth_sendRawTransaction需要完整交易签名
        - 交易构造：
            - 必需字段：from/to/value/gas/data等
            - 签名过程：需用私钥对交易数据进行签名
            - EIP-1559参数：maxPriorityFeePerGas和maxFeePerGas
            - ![[0d84333c027b4bd2f8849186bda517f0_MD5.jpg]]
        - 完整流程：
            - 编码函数调用数据
            - 构造原始交易对象
            - 使用私钥签名
            - 通过节点广播交易
        - 安全机制：节点会验证签名有效性，网络共识确认后交易才最终生效
    - 与节点交互的库﻿22:24﻿
        - ![[a1cf35863d6b2318448e5981fd743d8f_MD5.jpg]]
        - 主流工具：
            - JavaScript：viem.js/ethers.js/web3.js
            - Java：Web3J
            - Python：Web3Py
            - Go：go-ethereum
            - Rust：alloy-rs
        - 封装优势：
            - 简化参数构造过程
            - 提供类型检查和错误处理
            - 支持Promise等现代编程特性
        - 底层原理：所有库最终都转换为标准JSON-RPC请求与节点交互
- 应用案例﻿22:52﻿
    - cast命令使用
        - ![[ab8de895a2c987c818ec7b377a6d69b5_MD5.jpg]]
        - 功能概述: cast命令包含多种与区块链交互的功能，是对JSON-RPC接口的封装
        - 常用命令:
            - hash-message: 根据EIP-191标准哈希消息
            - hash-zero: 打印零哈希
            - keccak: 使用Keccak-256算法哈希任意数据
            - namehash: 计算ENS名称哈希
            - nonce: 获取账户nonce值
            - parse-units: 将十进制数转换为最小单位
            - send: 签名并发布交易
            - storage: 获取合约存储槽原始值
            - ![[eed5a4c8b90a1960a10bc7479687106c_MD5.jpg]]
        - 命令选项:
            - --color: 控制日志颜色输出(auto/always/never)
            - --json: 以JSON格式输出日志
            - -q/--quiet: 不打印日志消息
            - -V/--verbosity: 设置日志详细级别(可叠加使用)
                - -v: 基本详细
                - -vv: 打印所有测试日志
                - -vvv: 打印失败测试的执行跟踪
                - -vvvv: 打印所有测试的执行跟踪
    - Web3开发库
        - ![[9b29d12891e2135530b401f07a6b0d72_MD5.jpg]]
        - 本质: 都是对JSON-RPC接口的封装，简化开发过程
        - 主流库:
            - JavaScript: viem.js/ethers.js/web3.js
            - Java: Web3J
            - Python: Web3Py
            - Go: go-ethereum
            - Rust: alloy-rs
        - 核心概念:
            - Provider/Client: 与区块链节点连接的抽象
            - 不同语言库用法相似，掌握一个即可触类旁通
            - ![[64960136350ecb9c2c906cfed78a0e7b_MD5.jpg]]
        - viem特点:
            - 轻量级、模块化设计
            - 完全类型安全(TypeScript)
            - 性能优于其他库
            - 文档完善(含中文版)
        - 基本使用:
    - ![[1c21e79dbf072977deee24bc8d2839fa_MD5.jpg]]
    - 封装方法:
        - eth_blockNumber: 获取最新区块号
        - eth_call: 执行合约调用
        - eth_getBalance: 查询账户余额
        - eth_sendRawTransaction: 广播签名交易
        - eth_getTransactionReceipt: 获取交易收据
    - 开发库选择建议
        - 当前趋势:
            - 最常用: viem.js
            - 次常用: ethers.js
            - 已淘汰: web3.js
        - 学习建议:
            - 掌握一个库即可理解核心概念
            - 不同语言库本质相同，只是语法差异
            - 实际使用时查阅对应文档即可
- 使用Viem﻿25:46﻿
    - Viem介绍：Viem.sh逐步取掉ethers.js和web3.js，高性能、模块化、轻量级、更出色的开发人员体验。
    - 安装：node.js v16以上，使用pnpm install viem或npm install viem。
    - client作用：client是交互载体，使用所需的链传输协议创建client读取链上数据。
    - 例题:Viem应用示例﻿28:02﻿
        - ![[5a5635d65591e19bb19421a335825157_MD5.jpg]]
        - 创建公共客户端：
            - 导入模块：从'viem'导入createPublicClient，http；从'viem/chains'导入mainnet。
            - 创建过程：使用createPublicClient函数，指定链为mainnet，传输协议为http()，代码示例如下：

import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'
const client = createPublicClient({chain: mainnet,transport: http( ),})

    - ​**​获取区块高度​**​：通过创建的`client`调用`getBlockNumber`方法获取区块高度，示例代码如下：

const blockNumber = await client.getBlockNumber()

- ​**​获取地址余额​**​：
    - ​**​格式化余额​**​：使用`formatEther`方法对获取的余额进行格式化。
    - ​**​获取过程​**​：通过`publicClient`调用`getBalance`方法，传入地址参数获取余额，示例代码如下：

const tbalance = formatEther(await publicClient.getBalance({
    address: "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
}));
console.log(`The balance of 0xf39 is${tbalance}`);

- ​**​创建钱包客户端​**​：
    - ​**​导入私钥到账户​**​：从"viem/accounts"导入`privateKeyToAccount`。
    - ​**​创建过程​**​：使用`privateKeyToAccount`方法传入环境变量中的私钥创建账户，再通过`createWalletClient`方法传入账户创建钱包客户端，示例代码如下：

import { privateKeyToAccount } from "viem/accounts";
const account = privateKeyToAccount(process.env.PRIVATE_KEY! as string);
const walletClient = createWalletClient({ account });

- ​**​题目解析​**​：
    - ​**​代码结构​**​：代码分为创建公共客户端、获取区块高度、获取地址余额、创建钱包客户端几个部分。
    - ​**​关键方法​**​：`createPublicClient`、`getBlockNumber`、`getBalance`、`privateKeyToAccount`、`createWalletClient`。
    - ​**​环境变量​**​：使用`dotenv.config()`加载环境变量，通过`process.env`获取`RPC_URL`和`PRIVATE_KEY`。
    - ​**​示例地址​**​：代码中使用的地址为`0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266` ，合约地址为`0x5FbDB2315678afecb367f032d93F642f64180aa3`。
    - ​**​传输协议​**​：创建公共客户端时，传输协议`transport`有两种，一种是`web socket`，一种是`http`，当要监听链上的一些数据的时候，就用`web socket`。

- 应用案例
    - 例题：转账操作﻿31:09﻿
        - 框架特点:
            - 逐步替代ethers.js和web3.js
            - 具有高性能、模块化、轻量级特性
            - 提供更出色的开发人员体验
        - 安装要求:
            - Node.js v16以上版本
            - 安装命令：pnpm install viem 或 npm install viem
        - PublicClient:
            - 用于读取链上数据
            - 示例代码：
        - WalletClient:
            - 用于发起交易（需要签名）
            - 需要配置私钥信息（通常通过.env文件）
            - 示例代码：
        - ![[b47b10001383fef709084325d4367188_MD5.jpg]]
        - 交易特点:
            - 发起交易后不能立即获取结果，只能获取交易哈希
            - 交易结果需要等待区块确认后才能获取
        - 转账示例:
            - 基础转账：
        - 自定义参数转账：
        - ![[1f4fb0128bff3321ec1a15af108df57d_MD5.jpg]]
        - 交易验证:
            - 通过区块高度变化确认交易完成
            - 余额变化验证（扣除转账金额和手续费）
            - 手续费计算基于最近交易的平均gas消耗
            - ![[d496289f155fad1ce93cb35e6d85c8b6_MD5.jpg]]
        - 合约调用流程:
            - 将函数调用转换为HEX格式：myFunction(parameters)→0xabcdef0123456789
            - 构建交易对象：
        - 使用私钥签名交易
        - 将交易发送到以太坊网络
        - 合约读取方法:
            - 方法一：创建合约对象后调用read方法
                - 需要合约地址和ABI
                - 示例：balanceOf方法调用
            - 方法二：通过publicClient直接调用
                - 使用readContract方法
                - 需要提供合约地址、ABI、方法名和参数
            - 两种方法最终都会将调用转换为ABI编码发送到链上
- 应用案例﻿37:42﻿
    - 例题:合约调用示例
        - ![[669c4ea99501c0ba60ace35ed5371bc2_MD5.jpg]]
        - 创建合约对象：
            - client类型：如果要写合约对象，后面要加上wallet connect；如果仅仅是读合约，使用public即可。
            - 代码示例：

const walletClient = createwalletClient({
    account,
    transport: http(process.env.RPC_URL!),
}).extend(publicActions);

- ​**​读取合约数据​**​：
    - ​**​获取钱包地址​**​：

const address = await walletClient.getAddresses();
console.log(`The wallet address is${address}`);

    - ​**​发送交易​**​：

const hash1 = await walletClient.sendTransaction({
    account,
    to: "0x01BF49D75f2b73A2FDEFa7664AEF22C86c5Be3df",
    value: parseEther("0.001"),
});
console.log(`默认 gas 和 nonce 的 transaction hash is${hash1}`);

- ​**​部署ERC20合约​**​：
    - ​**​Foundry工具​**​：Foundry是一个快速、便携、模块化的以太坊应用开发工具包，用Rust编写。
    - ​**​Foundry组件​**​：
        - ​**​Forge​**​：以太坊测试框架（类似Truffle、Hardhat和DappTools）。
        - ​**​Cast​**​：与EVM智能合约交互、发送交易和获取链数据的瑞士军刀。
        - ​**​Anvil​**​：本地以太坊节点，类似于Ganache和Hardhat Network。
        - ​**​Chisel​**​：快速、实用、详细的Solidity REPL。
    - ​**​部署步骤​**​：
        - 使用`forge script`部署ERC20合约。
        - 合约部署到本地节点。
        - 部署成功后，获取合约地址。

// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
contract MyERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 10000 * 10​**​18);
    }
}

- ​**​自定义Gas和Nonce​**​：

const hash2 = await walletClient.sendTransaction({
    maxFeePerGas: parseUnits("20", "gwei"),
    maxPriorityFeePerGas: parseGwei("2"),
    to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
    value: parseEther('1'),
    nonce: 1,
});
console.log(`自定义 gas 和 nonce 的 transaction hash is${hash2}`);

- ​**​交易信息​**​：
    - ​**​交易1​**​：
        - ​**​Transaction​**​：0x57292aef5889691acff881e0814302981763d916efd12b7d018ac52494ac9605
        - ​**​Gas used​**​：21000
        - ​**​Block Number​**​：1
        - ​**​Block Hash​**​：0xb866f274d86edf9766f4414cc6695e12dac948e09b04d5bd45b47dd0e5e9d183
        - ​**​Block Time​**​："Tue, 29 Jul 2025 12:42:12 +0000"
    - ​**​交易2​**​：
        - ​**​Transaction​**​：0x21ddf08ccff35bb46e6f50d887db99a6d307029bf8dd8253d63320517b0be91e
        - ​**​Gas used​**​：21000
        - ​**​Block Number​**​：2
        - ​**​Block Hash​**​：0xbb806f3334742ead7f27f539bd531e6bd6f1fe40f0e582e1ad8fbaeea74ebae9
        - ​**​Block Time​**​："Tue, 29 Jul 2025 12:43:07 +0000"
    - ​**​交易3​**​：
        - ​**​Transaction​**​：0xab6c847e02ecb2c7ca0974feadb6fa02f7135e5b82cef11fd838ae0faa616be2
        - ​**​Contract created​**​：0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0
        - ​**​Gas used​**​：947952
        - ​**​Block Number​**​：3
        - ​**​Block Hash​**​：0x0c200330c2f28adf64e1344d23778c1ab1b7da40269f19b8e6352
        - ​**​Block Time​**​："Tue, 29 Jul 2025 12:49:00 +0000"
- ​**​与合约交互（读）​**​：
    - ​**​使用Viem调用ERC20合约​**​：
        - ​**​方法1​**​：创建client（public client），然后创建合约对象（合约地址+ABI+client），最后从合约获取数据（参数）。

const contract = getContract({
    address: WETH_ADDRESS,
    abi: WETH_ABI,
    client: {
        public: publicClient,
        // wallet: walletClient,
    },
});
contract.read.balanceOf([userAddress]);

        - ​**​方法2​**​：使用client的readContract（合约地址+ABI+参数）。

publicClient.readContract({
    address: WETH_ADDRESS,
    abi: WETH_ABI,
    functionName: "balanceOf",
    args: [address.toString()],
});

    - ​**​导出ABI​**​：

forge inspect MyERC20 abi-json > MyERC20.json

- 使用Viem﻿40:48﻿
    - 合约读取操作﻿43:07﻿
        - ![[161ceaccbf90f67f82842f5383578d2f_MD5.jpg]]
        - ABI导出方法：使用forge inspect MyERC20 abi -json > MyERC20.json命令导出合约ABI，生成的JSON文件可被前端工程调用
        - 工程结构建议：智能合约工程可以与前端工程合并，也可分开存放。若分开存放需要手动拷贝ABI文件到前端工程目录
        - 余额读取方法1：
            - 创建public client连接区块链节点
            - 通过getContract创建合约对象（需合约地址+ABI+client）
            - 调用合约read方法获取数据，如contract.read.balanceOf([userAddress])
        - 余额读取方法2：
            - 直接使用publicClient的readContract方法
            - 参数包含合约地址、ABI、函数名和参数数组
            - 两种方法读取结果相同，方法1可读性更好，方法2编写更便捷
            - ![[388ee6da483aef2ef2c9d88b64840f62_MD5.jpg]]
        - 数据格式化：合约返回的余额数据是18次方的大整数，需要使用formatEther进行格式化显示
        - 部署设置：示例中MyERC20合约在部署时固定发行了10000个代币，这是通过构造函数中的_mint(msg.sender, 10000 * 10 ​**​ 18)实现的
    - 合约写入操作﻿45:52﻿
        - 核心区别：写入操作需要钱包客户端(walletClient)进行交易签名，而读取操作只需publicClient
        - 写入方法1：
            - 通过合约对象的write方法调用
            - 如counterContract.write.increment()
            - 返回交易哈希而非直接结果
        - 写入方法2：
            - 使用walletClient的writeContract方法
            - 需完整指定合约地址、ABI、函数名和参数
        - 交易确认：写入操作返回的是交易哈希，需要等待链上确认后才能获取最终执行结果
        - ![[66122c20dee9ae7c5da5672d46f577e0_MD5.jpg]]
        - 无参函数调用：示例中的increment函数不需要参数，若有参数需在前端调用时传入
        - 交易状态检查：交易收据中的status字段表示执行是否成功，true表示成功
        - 账户关联：合约交互会使用walletClient关联的账户进行交易签名和gas支付
- 从交易中获取事件
    - 交易结果获取机制
        - ![[b66044ed210a5a9d0f6fb740c104ee2b_MD5.jpg]]
        - 交易哈希特性：发起交易时不会立即返回执行结果，而是返回该交易的哈希值（Hash）。这个哈希值可以在区块链浏览器上查询到交易详情。
        - 本地网络限制：在本地测试网络执行的交易哈希，无法直接在以太坊主网的区块链浏览器上查询。
    - 交易收据解析方法
        - ![[6ff24db997aa9b1e4ce8f58affcc161a_MD5.jpg]]
        - 等待确认：通过waitForTransactionReceipt方法等待交易上链确认，获取交易收据(receipt)。
        - 状态检查：收据中的status字段显示交易最终状态（'success'或'failure'）。
        - 日志解析：使用parseEventLogs方法从收据的logs中解析特定事件（如ERC20的Transfer事件），需要提供ABI和事件名称。
    - 事件详情提取
        - ![[e3e609b62a7f4c5de3ee802af8321a55_MD5.jpg]]
        - 事件遍历：通过循环遍历解析后的事件日志(transferLogs)，可获取每个事件的详细参数。
        - 参数提取：Transfer事件包含三个关键参数：
            - from: 转账发起地址
            - to: 收款地址
            - value: 转账金额（以bigint类型存储）
        - 格式转换：金额值需要通过formatEther等方法转换为可读格式。
    - 区块链浏览器验证
        - ![[022aad546059aaddc8c35b6a246c7a20_MD5.jpg]]
        - 公开查询：所有成功上链的交易都可以通过交易哈希在Etherscan等区块链浏览器上查询详细信息。
        - 开发辅助：浏览器提供交易状态、Gas消耗、区块确认数等关键信息，是开发调试的重要工具。

#### 二、从交易中获取事件﻿50:52﻿

##### 1. 交易结果获取机制

- ![[d95b7ac528f0b8d28eb6d03fd2e88a71_MD5.jpg]]
- 交易收据特性：区块链交易不会直接返回执行结果，而是返回交易哈希（Hash），需要通过交易收据（receipt）获取最终状态
- 结果获取方法：
    - 使用waitForTransactionReceipt等待交易上链
    - 从收据的status字段读取交易状态（success/failure）
    - 示例代码：

##### 2. 事件解析方法

- ![[98c3b79ee2bda08e7026d143e7b1c10f_MD5.jpg]]
- 事件存储位置：所有合约触发的事件都存储在交易收据的logs字段中
- 解析工具：使用parseEventLogs方法解析特定事件
    - 需要提供：合约ABI、事件名称、原始日志数据
    - 示例（解析Transfer事件）：
- 事件参数提取：
    - 每个事件可能包含多个日志记录（数组形式）
    - 通过ABI定义的事件参数结构进行类型转换
    - 示例输出转账详情：

##### 3. ERC20事件结构

- ![[05d52414387f48609e5abd6f77761748_MD5.jpg]]
- 标准事件格式：Transfer事件包含三个索引参数
    - from：转出地址（indexed address）
    - to：转入地址（indexed address）
    - value：转账金额（uint256）
- ABI定义示例：
- 解析原理：ABI定义使解析器能正确识别日志中的参数位置和类型

##### 4. 问题输出﻿52:48﻿

- ![[92a0bc4c5fdf2ffaedb80c1a9aaf90a7_MD5.jpg]]
- 典型输出内容：
    - 交易哈希（Transaction Hash）
    - 合约地址（Contract Address）
    - Gas消耗（Gas Used）和费用（Gas Cost）
    - 交易状态（Success/Failure）
- 调试技巧：
    - 打印完整收据对象查看所有可用字段
    - 注意日志数组可能包含多个合约的混合事件
    - 使用类型断言确保参数类型安全

#### 三、监听事件﻿53:58﻿

##### 1. 获取交易结果

- ![[125ef84fd815ab1951eaba9f2c903eb6_MD5.jpg]]
- 交易结果获取方式：区块链交易不会直接返回结果，而是返回交易Hash。需要通过等待交易上链并解析日志来获取最终结果。
- 代码实现：

##### 2. 实时监听事件

- ![[59d51ce88568d22973d9a069c84b4ed7_MD5.jpg]]
- 监听场景：当需要实时监听链上发生的事件时使用，特别是监控他人发起的与合约交互的交易。
- 技术实现：
    - 使用WebSocket建立长连接
    - 通过watchEvent方法监听特定事件
- 代码示例：

##### 3. 监听事件注意事项

- 连接方式：必须使用WebSocket协议而非HTTP，因为需要保持长连接。
- 地址匹配：监听时必须确保合约地址正确，否则无法捕获事件。
- 实际应用：
    - 后端服务可将监听到的交易数据存入数据库
    - 用户端交互需要通过钱包发起，不能直接在代码中硬编码私钥
- 调试技巧：可以通过在另一个终端执行交易来测试监听功能是否正常工作。

#### 四、DApp开发﻿58:13﻿

##### 1. 前端与合约交互

###### 1）不同点

- 钱包集成方式：必须通过用户钱包创建client，而非直接使用私钥创建。MetaMask等钱包插件会在安装后向页面注入
    
    ﻿window.ethereumwindow.ethereumwindow.ethereum﻿
    
    对象
- 客户端创建：通过createWalletClient方法创建客户端时，需使用
    
    ﻿window.ethereumwindow.ethereumwindow.ethereum﻿
    
    作为transport参数

const walletClient = createWalletClient({
  chain: foundry,
  transport: custom(window.ethereum)
});

###### 2）前端交互时，注意链上交易的异步特性﻿59:22﻿

- 结果获取：无法直接获取交易发起结果，需要通过事件监听或交易哈希查询
- 用户授权：所有写操作需通过钱包插件弹出授权窗口，用户手动确认签名
- 网络切换：需处理用户切换网络的情况（如从Foundry切换到主网）

###### 3）应用案例﻿01:00:27﻿

- 示例代码
    - ![[81d0c30f51a2d938a292257e4561f796_MD5.jpg]]
    - 连接流程：
        - 检查
            
            ﻿window.ethereumwindow.ethereumwindow.ethereum﻿
            
            是否存在
        - 调用
            
            ﻿ethrequestAccountseth_requestAccountsethr​equestAccounts﻿
            
            请求账户授权
        - 监听账户变化事件accountsChanged

const connectWallet = async () => {
  if(typeof window.ethereum === 'undefined'){
    alert('请安装MetaMask');
    return;
  }
  const [address] = await window.ethereum.request({
    method: 'eth_requestAccounts'
  });
  // 后续处理...
}

- 示例代码﻿01:00:59﻿
    - ![[5fa090fd45cbe19129d329980a89977e_MD5.jpg]]
    - 写操作实现：
        - 使用
            
            ﻿walletClient.writeContractwalletClient.writeContractwalletClient.writeContract﻿
            
            方法
        - 需包含合约地址、ABI、函数名等参数
        - 返回交易哈希而非直接结果

const handleIncrement = async () => {
  const hash = await walletClient.writeContract({
    address: COUNTER_ADDRESS,
    abi: Counter_ABI,
    functionName: 'increment',
    account: address
  });
  console.log('Transaction hash:', hash);
}

- 完整项目：参考GitHub示例代码库 https://github.com/lbc-team/hello_viem/tree/main/viem-front
- 调试技巧：在Foundry本地网络开发时需确保MetaMask连接的是正确链ID（如31337）

#### 五、知识小结

|   |   |   |   |
|---|---|---|---|
|知识点|核心内容|考试重点/易混淆点|难度系数|
|Web3应用架构|对比Web1（只读）、Web2（可交互）、Web3（可拥有）的核心差异，强调数据所有权和去中心化特性|Web3的“可拥有”特性如何通过区块链签名机制实现|⭐⭐|
|合约与前端交互|合约作为后端角色，需结合前端/后端组成完整应用；RPC调用是交互本质，但通常通过封装库（如viem）实现|直接使用RPC的场景（冷门语言无封装库）|⭐⭐⭐|
|链上交互类型|读合约内容/链状态、写交易、监听事件；异步处理特性（交易结果需等待区块确认）|交易哈希与交易收据的区别，如何通过收据获取事件日志|⭐⭐⭐⭐|
|开发工具链|viem.js库（替代web3.js）、Foundry的cast命令、MetaMask钱包注入的window.ethereum对象|viem的publicClient（读）与walletClient（写）分工|⭐⭐⭐|
|合约调用演示|两种调用方式：1. 构造合约对象后调用 2. 直接通过client的readContract/writeContract|ABI编码的自动处理与手动构造对比|⭐⭐⭐⭐|
|事件监听|使用watchEvent+WebSocket长连接实时监听链上事件（如ERC20转账）|事件监听与交易收据解析的关联性|⭐⭐⭐|
|前端集成|通过MetaMask获取用户签名，避免前端硬编码私钥；window.ethereum.request授权流程|钱包连接的安全边界与用户授权提示|⭐⭐⭐⭐|
|作业实践|为TokenBank合约添加存款前端界面，并实现买卖记录监听功能|前端状态管理与链上数据同步的挑战|⭐⭐⭐⭐|
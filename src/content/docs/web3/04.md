---
title: "04"
description: ""
order: 4
---

## 一、特殊函数 (Constructor)

### 1. 构造函数

- ![[c1a12c047cdc1c78a574f53dead6a2cb_MD5.jpg]]
- **执行时机**：仅在合约部署时执行一次，执行完成后不会保留在链上字节码中。
- **链上存储**：链上存储的是构造函数执行后的结果状态，而非构造函数本身的代码。
- **初始化作用**：主要用于合约状态的初始化逻辑设置。

---

### 2. 不同的字节码

- ![[8149ee673e13141a4d3689a7b5ed71a2_MD5.jpg]]
- **编译字节码**：由 **Solidity** 编译器直接生成的原始字节码。
- **创建字节码**：
    - 包含**编译字节码**和构造函数参数编码。
    - 部署合约时实际发送到链上的字节码形式。
    - 示例中显示比**编译字节码**长，因为附加了参数编码（如示例中的参数 **10** 编码为 `0x000...000a`）。
- **运行时字节码**：
    - 构造函数执行后存储在链上的最终字节码。
    - 比**创建字节码**更短，不包含构造函数逻辑。
    - 示例中通过区块浏览器可查看合约地址存储的字节码。
    - ![[f51e217f491dbec7797acda7785c342f_MD5.jpg]]
- **演示过程**：
    - 部署包含构造函数的 **Counter** 合约（参数 **x = 10**）。
    - 通过 **Remix** 编译器查看编译产生的原始字节码。
    - 在 **Etherscan** 查看实际部署的交易数据中的**创建字节码**。
    - 对比合约地址存储的**运行时字节码**。
- **关键区别图解**：
    - **创建字节码** = 编译字节码 + 参数编码。
    - **运行时字节码** = 执行构造函数后的状态字节码。
    - ![[2eb851773855af86d7198bbd0d4fcbc2_MD5.jpg]]
- **查看方法**：
    - 通过区块浏览器进入合约地址。
    - 在 **"Contract"** 标签页查看存储的**运行时字节码**。
    - 对比编译时和部署时的字节码差异。

## 二、自定义修饰符 (Modifiers)

### 1. 函数修改器

#### 1) 使用 modifier 关键字定义修改器

- ![[7a442c594d59310897d282ab486a4528_MD5.jpg]]
- **定义语法**：使用 `modifier` 关键字定义修改器，如：
```solidity
modifier onlyOwner() { 
	require(msg.sender == owner, "Not owner");
	 _; 
}
```

- **下划线作用**：特殊符号 `_` 表示被修饰函数的函数体将插入到该位置执行。
- **概念类比**：类似于 **Python** 中的装饰器概念，用于扩展或约束函数行为。

#### 2) 应用修改器到函数

- ![[9896d4f9b1792f44d4725886c2ce2918_MD5.jpg]]
- **应用方式**：在函数声明的可见性修饰符后添加修改器名称，如 `function withdraw() public onlyOwner`。
- **执行流程**：调用函数时会先跳转执行修改器中的逻辑，当遇到 `_` 时再返回执行函数体。
- **典型用途**：检查输入条件、控制权限访问（ACL）、防止重入攻击等。
- **全局上下文**：经常与内置全局变量 `msg.sender` 结合使用，判别当前调用者权限。

#### 3) 修改器的进阶特性

- ![[97d455c74a2c5692b582889c624a1952_MD5.jpg]]
- **参数传递**：修改器支持接收参数，例如年龄验证：`modifier over22(uint age) { ... }`。
- **嵌套应用**：支持在一个函数上挂载多个修改器，按照从左到右的顺序嵌套执行。
- **编译原理**：在底层，这是一种“语法糖”。编译器会将修改器中的代码与函数体进行文本级别的组合扩展。

#### 4) 底层限制与开发建议

- ![[3dd0d808ab371b8b92786492eb39b2f4_MD5.jpg]]
- **代码膨胀风险**：由于修改器会在每个被修饰的函数处进行代码扩展，过度使用可能导致合约超过 **24KB** 的部署大小限制。
- **替代方案 (私有函数)**：对于逻辑极其复杂的校验，建议提取为 `private` 函数。私有函数通过 `JUMP` 跳转实现，几乎不增加字节码体积。
- **最佳实践**：简单逻辑（如权限检查）使用 `modifier`；复杂业务逻辑使用私有函数。

---

## 三、EVM 错误处理 (Error Handling)

### 1. 传统语言的错误处理

- ![[55e0ee18f95a83d8c24e5c8ed8a2f4b1_MD5.jpg]]
- **执行特点**：在 **Java** 等传统语言中，程序执行到出错点时，前面已执行的代码会保持生效状态，后续代码不再执行。
- **状态保留**：如文件写入操作，出错前的写入内容会保留在文件中。

### 2. EVM 的错误处理特性

#### 1) 事务的原子性与回滚机制

- ![[2255cb9a4649c5eb3776fa63bba9ee4e_MD5.jpg]]
- **原子性保证**：当 **EVM** 遇到未处理的错误时，会回滚所有状态变更，恢复到交易前的初始状态。
- **状态一致性**：确保交易要么全部成功，要么完全失败，不会出现“部分成功”的情况。
- **Gas 消耗**：即使交易失败，已执行消耗的 **Gas** 仍会被扣除。

###### 2）错误处理工具

- **require()**：用于输入条件检查、外部合约返回值验证。
- **assert()**：检查代码不应出现的状态（如除零、数组越界）。若触发，抛出 **Panic** 错误。
- **revert()**：显式终止执行并回滚。
- **自定义 Error (0.8.4+)**：使用 `error NotOwner(); revert NotOwner();` 语法。相比字符串报错可节省约 **4.5% - 10%** 的 **Gas** 开销。
**例题：Gas 消耗量对比**
    - ![[a80d075110bedbf9ecc677da2002ae77_MD5.jpg]]
    - 测试方法:
        - 分别使用require字符串和自定义Error实现相同权限检查
        - 使用不同账户触发错误条件
    - 结果分析:
        - 字符串错误消耗2341 Gas
        - 自定义Error消耗2236 Gas
        - 节省约4.5% Gas消耗

#### 3) try/catch 机制 (仅限外部调用)
![[c4ceddd018fbe05ce7530e5aee2b651a_MD5.jpg]]
- 
- **适用场景**：**仅适用于外部合约调用**（**external call**）。
- **逻辑优势**：允许主合约在被调用合约失败时捕获异常，而不至于让整个父交易流回滚。
- **局限性**：**无法捕获**同一合约内部函数产生的回退。
**例题：try/catch 处理外部调用异常**
    - ![[1e50a2b68e1e69c54892e643c6ab519a_MD5.jpg]]
    - 实验设计:
        - 部署包含require检查的Foo合约
        - 部署TryCatch合约调用Foo合约
        - 分别测试直接调用和try/catch调用
    - 结果对比:
        - 直接调用：交易完全回滚
        - try/catch调用：错误被捕获，主合约继续执行
        - 错误信息可存储在状态变量中

#### 4) try/catch 的无法捕获场景

- ![[f95123fdb773004cfa9dedbf15b1a0ec_MD5.jpg]]
- **风险预警**：
    1.  **调用非合约地址**：向空地址（无代码）发起调用将导致静默失败或直接报错，**不可被 try/catch 捕获**。
    2.  **Gas 耗尽**：属于系统级停堆，代码逻辑无法拦截。
- **建议**：在发起调用前，应使用 `extcodesize` 验证目标地址有效性。
**例题：合约调用错误验证**
    - ![[b0c29e00d617f8e5feb85b5436bff891_MD5.jpg]]
    - 测试方法:
        - 向非合约地址（0x5B3...eddC4）发起调用
        - 观察交易状态和Gas消耗
    - 结论验证:
        - 交易状态显示"errored"
        - 错误信息为"revert"
        - 证明此类错误无法被try/catch捕获


---

## 四、接口与继承 (Interfaces & Inheritance)

### 1. 接口 (Interfaces)

#### 1) 接口的定义及特性

- ![[10e782645d0a2b0a7a0b8915c5810a12_MD5.jpg]]
- **定义**：**接口**是只包含函数声明的类型，用于合约间解耦调用。
- **核心特性**：
    - **无实现**：仅声明函数签名，不能包含函数体。
    - **限制性**：不能继承其他合约或接口、无构造函数、无状态变量。
    - **抽象性**：相当于函数的抽象声明集合，类似于传统语言的 **Abstract Method**。
- **应用场景**：
    - 合约间解耦调用。
    - 标准化功能定义（如 **ERC20** 标准）。
    - 代码组织与复用。
    - ![[5fb4d81b04896c77c1b37ec3ed34a0ec_MD5.jpg]]
- **调用机制**：
    - 通过**函数选择器**（如 `0x4df...7e3d0`）准确定位目标函数。
    - 只需已知函数签名即可发起跨合约调用，无需依赖完整源代码。
    - 典型调用语法：`ICounter(_counter).increment()`。

### 2. 继承 (Inheritance)

#### 1) 继承的定义及特性

- ![[d3ca8f073bff2c844cb6ea7dbf47a98c_MD5.jpg]]
- **语法结构**：使用 `is` 关键字（如 `contract B is A`）。
- **编译特性**：
    - 基类代码在编译时会自动嵌入到派生合约中。
    - 链上仅部署最终生成的派生合约。
    - 基类的**状态变量**会按顺序占用派生合约的存储槽位置。
- **访问控制**：
    - 可访问父合约中所有非 `private` 成员。
    - `internal` 成员可被子合约直接引用。
    - `private` 变量虽然在链上实际占用存储空间，但对子合约逻辑不可见。
    - ![[979c7a266bf3eceaed7e34c803420927_MD5.jpg]]
- **存储特点**：
    - **私有变量**（`private`）仍会在合约存储中分配空间。
    - 开发者可通过底层的 **RPC** 方法（如 `eth_getStorageAt`）直接读取这些敏感数据。
    - 安全提醒：在派生合约中，私有变量虽不可见，但其物理存储实际上一直伴随。

### 3. 抽象合约 (Abstract Contracts)

#### 1) 抽象合约特性

- ![[8ada9ecb1a3d8c1a46224128662842b6_MD5.jpg]]
- **核心特征**：
    - 使用 `abstract` 关键字声明。
    - 允许包含未实现的纯虚函数。
    - **不能被直接部署**，必须被子合约继承实现。
- **关键修辞符**：
    - `virtual`：在父合约中标记可被子合约重写的函数。
    - `override`：在子合约中明确声明重写父合约中的同名函数。
    - `super`：用于显式调用父合约的已有实现（如 `super.add(b)`）。
    - ![[fbd0555c928633c45c9b85a56044dfe6_MD5.jpg]]
- **重写规则**：
    - 未明确标记 `virtual` 的函数严禁被子合约重写。
    - 执行重写操作时，必须携带 `override` 声明。
    - 在承接**多重继承**时，若同名函数存在于多个父合约中，重写时需显式列出所有路径。

---

## 五、实践作业 (Hands-on Practice)

- ![[cd57182d3b8de2601ef4bd005a1b3391_MD5.jpg]]
- **实现要求**：
    - 继承 `Bank` 合约实现 `BigBank`。
    - 使用 `modifier` 限制存款金额（必须 `> 0.001 ETH`）。
    - 引入 `Admin` 合约管理最终资金的提取。
- **技术要点**：
    - 合约间底层的调用模式（**Interface Call**）。
    - **ACL**（访问控制列表）的严谨实现。
    - 企业级资金托管架构的设计思路。

---


## 六、合约接口描述与编码 (ABI & Encoding)

### 1. 合约调用过程

- ![[22fbfd00fa732951b92431149bad5f4b_MD5.jpg]]
- **交易结构**：
    - **普通交易**：包含 **to** 地址、**value** 和 **data** 字段。
    - **创建合约**：**to** 字段为空地址，**data** 字段包含完整的合约字节码。
    - **调用合约**：**to** 为目标合约地址，**data** 字段包含对应函数的 **ABI** 编码。
- **调用本质**：所有合约调用最终都转化为向合约地址发送 **ABI** 编码数据的交易。

### 2. ABI (Application Binary Interface)

#### 1) ABI 接口描述

- ![[4439d2cc163016c412b1f88348769d36_MD5.jpg]]
- **作用**：定义如何与智能合约交互的标准接口规范。
- **生成方式**：由编译器在编译时自动生成 **JSON** 格式的描述文件。
- **必要性**：由于字节码无法直接反映合约逻辑接口，因此通过 **ABI** 元数据系统进行桥接。

#### 2) 函数选择器 (Function Selector)

- ![[5fbde8cd162609952054e38eadcc2847_MD5.jpg]]
- **计算方法**：对“函数签名”进行 **Keccak-256** 哈希运算，并截取结果的前 **4** 个字节。
    - 示例：`count()` → `keccak256("count()")` → **0x06661abd**。
- **特性**：
    - **忽略变量名**：仅关注函数名及其参数类型列表。
    - **类型扩展**：基本类型在哈希前会扩展为完整形式（例如 `uint` 会被视为 `uint256`）。
- **获取途径**：
    - 使用在线工具（如 **Keccak-256** 在线生成器）。
    - 访问 **4byte.directory** 签名数据库进行公开查询。
    - 在 **Solidity** 中通过 `abi.encodeWithSignature` 或 `.selector` 成员直接获取。

#### 3) 参数编码 (Argument Encoding)

- ![[799e214090e39adfaefc73a9c9522c76_MD5.jpg]]
- **编码规则**：
    - 参数会被扩展为 **32 字节**（**256 bits**）对齐的格式。
    - 示例：`set(10)` 调用产生的交易 **data** 为：`0x60fe47b1` (选择器) + `000...000a` (参数 **10** 经过 32 字节填充)。
- **注意事项**：
    - 参数编码顺序必须与函数签名保持严格一致。
    - 动态类型（如 `string`, `bytes`, 动态数组）涉及复杂的偏移量编码机制。

#### 4) 智能合约调用全流程

- ![[7b6da2016620b749e19a6fbbce12ca54_MD5.jpg]]
- **完整交互逻辑**：
    1.  将函数名与参数类型列表转换为 **HEX** 格式的 **ABI** 编码数据。
    2.  构造一个标准的交易对象（包含目标地址 **to**、转移币种 **value**、业务数据 **data**）。
    3.  使用该交易发起者的私钥进行加密签名。
    4.  通过节点将签名后的交易广播发送至以太坊网络。
- **节点执行机制**：节点在成功验证签名后，根据交易中的 **data** 片段（即 **ABI** 编码），在 EVM 内部匹配并触发对应的合约逻辑。

#### 5) Ethereum Signature Database (签名数据库)

- ![[72399d55430ba3c5a23097b56902c502_MD5.jpg]]
- **作用**：通过**函数选择器**（**HEX**）反向查询对应的原始**函数签名**。
- **特点**：目前包含超过 **130 万** 条公开的函数签名映射记录。
- **使用场景**：在分析未知合约或反编译合约代码时，用于确定具体的函数调用意图。

#### 6) 应用案例解析

- **例题：函数选择器获取示例**
    - ![[c6417ad6ea2710a2e912eeaea61377f0_MD5.jpg]]
    - **题目解析**：
        - 计算 `count()` 的函数选择器。
        - 使用 **Keccak-256** 在线工具进行哈希验证。
        - **答案**：`0x06661abd`。
- **例题：直接 ABI 编码调用合约函数示例**
    - ![[c6417ad6ea2710a2e912eeaea61377f0_MD5.jpg]]
    - **题目解析**：
        - 对比常规调用模式与底层 `call` 调用模式。
        - 演示 `abi.encodeWithSignature` 在合约交互中的实际作用。
        - **答案**：两种方式底层效果一致，但语义化与安全性程度不同。

### 3. 底层调用函数 (Low-level Calls)

- ![[f92f44dc7b668b2b70248bf21c8fdab6_MD5.jpg]]
- **语法形式**：`<address>.call(bytes memory) returns (bool, bytes memory)`
- **核心特点**：
    - **手动返回值处理**：必须手动接收并检查返回的 `bool` 值（表示交易执行是否成功）。
    - **永不触发回滚**：即使被调用函数失败，底层 `call` 也不会抛出异常，仅返回 `false`。
    - **高灵活性/低安全性**：适用于动态交互场景，但若缺乏严格检查，极易引发安全漏洞。
- **例题：计数器合约多维调用案例**
    - ![[13d77f87270c77f895aeb88a62e81ae9_MD5.jpg]]
    - **题目解析**：
        - 演示合约类型直接调用、**Interface** 实例化调用以及底层 `call` 调用。
        - 三种方式逻辑上均可实现计数器的递增操作。
        - **答案**：功能最终等效，但从代码健壮性角度，安全级别与其顺序成正比。

---





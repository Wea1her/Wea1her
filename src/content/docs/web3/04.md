## 一、特殊函数 (Constructor)

### 1. 构造函数

- ![[c1a12c047cdc1c78a574f53dead6a2cb_MD5.jpg]]
- **执行时机**：仅在合约部署时执行一次，执行完成后不会保留在链上字节码中。
- **链上存储**：链上存储的是构造函数执行后的结果状态，而非构造函数本身的代码。
- **初始化作用**：主要用于合约状态的初始化逻辑设置。

---

### 2. 不同的字节码

- ![[8149ee673e13141a4d3689a7b5ed71a2_MD5.jpg]]
- **编译字节码**：由 **Solidity** 编译器直接生成的原始字节码。
- **创建字节码**：
    - 包含**编译字节码**和构造函数参数编码。
    - 部署合约时实际发送到链上的字节码形式。
    - 示例中显示比**编译字节码**长，因为附加了参数编码（如示例中的参数 **10** 编码为 `0x000...000a`）。
- **运行时字节码**：
    - 构造函数执行后存储在链上的最终字节码。
    - 比**创建字节码**更短，不包含构造函数逻辑。
    - 示例中通过区块浏览器可查看合约地址存储的字节码。
    - ![[f51e217f491dbec7797acda7785c342f_MD5.jpg]]
- **演示过程**：
    - 部署包含构造函数的 **Counter** 合约（参数 **x = 10**）。
    - 通过 **Remix** 编译器查看编译产生的原始字节码。
    - 在 **Etherscan** 查看实际部署的交易数据中的**创建字节码**。
    - 对比合约地址存储的**运行时字节码**。
- **关键区别图解**：
    - **创建字节码** = 编译字节码 + 参数编码。
    - **运行时字节码** = 执行构造函数后的状态字节码。
    - ![[2eb851773855af86d7198bbd0d4fcbc2_MD5.jpg]]
- **查看方法**：
    - 通过区块浏览器进入合约地址。
    - 在 **"Contract"** 标签页查看存储的**运行时字节码**。
    - 对比编译时和部署时的字节码差异。

## 二、自定义修饰符 (Modifiers)

### 1. 函数修改器

#### 1) 使用 modifier 关键字定义修改器

- ![[7a442c594d59310897d282ab486a4528_MD5.jpg]]
- **定义语法**：使用 `modifier` 关键字定义修改器，如：
```solidity
modifier onlyOwner() { 
	require(msg.sender == owner, "Not owner");
	 _; 
}
```

- **下划线作用**：特殊符号 `_` 表示被修饰函数的函数体将插入到该位置执行。
- **概念类比**：类似于 **Python** 中的装饰器概念，用于扩展或约束函数行为。

#### 2) 应用修改器到函数

- ![[9896d4f9b1792f44d4725886c2ce2918_MD5.jpg]]
- **应用方式**：在函数声明的可见性修饰符后添加修改器名称，如 `function withdraw() public onlyOwner`。
- **执行流程**：调用函数时会先跳转执行修改器中的逻辑，当遇到 `_` 时再返回执行函数体。
- **典型用途**：检查输入条件、控制权限访问（ACL）、防止重入攻击等。
- **全局上下文**：经常与内置全局变量 `msg.sender` 结合使用，判别当前调用者权限。

#### 3) 修改器的进阶特性

- ![[97d455c74a2c5692b582889c624a1952_MD5.jpg]]
- **参数传递**：修改器支持接收参数，例如年龄验证：`modifier over22(uint age) { ... }`。
- **嵌套应用**：支持在一个函数上挂载多个修改器，按照从左到右的顺序嵌套执行。
- **编译原理**：在底层，这是一种“语法糖”。编译器会将修改器中的代码与函数体进行文本级别的组合扩展。

#### 4) 底层限制与开发建议

- ![[3dd0d808ab371b8b92786492eb39b2f4_MD5.jpg]]
- **代码膨胀风险**：由于修改器会在每个被修饰的函数处进行代码扩展，过度使用可能导致合约超过 **24KB** 的部署大小限制。
- **替代方案 (私有函数)**：对于逻辑极其复杂的校验，建议提取为 `private` 函数。私有函数通过 `JUMP` 跳转实现，几乎不增加字节码体积。
- **最佳实践**：简单逻辑（如权限检查）使用 `modifier`；复杂业务逻辑使用私有函数。

---

## 三、EVM 错误处理 (Error Handling)

### 1. 传统语言的错误处理

- ![[55e0ee18f95a83d8c24e5c8ed8a2f4b1_MD5.jpg]]
- **执行特点**：在 **Java** 等传统语言中，程序执行到出错点时，前面已执行的代码会保持生效状态，后续代码不再执行。
- **状态保留**：如文件写入操作，出错前的写入内容会保留在文件中。

### 2. EVM 的错误处理特性

#### 1) 事务的原子性与回滚机制

- ![[2255cb9a4649c5eb3776fa63bba9ee4e_MD5.jpg]]
- **原子性保证**：当 **EVM** 遇到未处理的错误时，会回滚所有状态变更，恢复到交易前的初始状态。
- **状态一致性**：确保交易要么全部成功，要么完全失败，不会出现“部分成功”的情况。
- **Gas 消耗**：即使交易失败，已执行消耗的 **Gas** 仍会被扣除。

###### 2）错误处理工具

- **require()**：用于输入条件检查、外部合约返回值验证。
- **assert()**：检查代码不应出现的状态（如除零、数组越界）。若触发，抛出 **Panic** 错误。
- **revert()**：显式终止执行并回滚。
- **自定义 Error (0.8.4+)**：使用 `error NotOwner(); revert NotOwner();` 语法。相比字符串报错可节省约 **4.5% - 10%** 的 **Gas** 开销。
**例题：Gas 消耗量对比**
    - ![[a80d075110bedbf9ecc677da2002ae77_MD5.jpg]]
    - 测试方法:
        - 分别使用require字符串和自定义Error实现相同权限检查
        - 使用不同账户触发错误条件
    - 结果分析:
        - 字符串错误消耗2341 Gas
        - 自定义Error消耗2236 Gas
        - 节省约4.5% Gas消耗

#### 3) try/catch 机制 (仅限外部调用)
![[c4ceddd018fbe05ce7530e5aee2b651a_MD5.jpg]]
- 
- **适用场景**：**仅适用于外部合约调用**（**external call**）。
- **逻辑优势**：允许主合约在被调用合约失败时捕获异常，而不至于让整个父交易流回滚。
- **局限性**：**无法捕获**同一合约内部函数产生的回退。
**例题：try/catch 处理外部调用异常**
    - ![](https://thumbnail0.baidupcs.com/thumbnail/a508cb8ebt83c72b0065d0cc57ac60f1?chkbd=0&chkv=0&dp-callid=0&dp-logid=345256207833406882&expires=8h&fid=1186958175-250528-903690020622204&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-ofGaO1Yp8zoBzx0GqiIYKFheGTE%3D&size=c1080_u1080&time=1767510000&vuk=1186958175)
    - 实验设计:
        - 部署包含require检查的Foo合约
        - 部署TryCatch合约调用Foo合约
        - 分别测试直接调用和try/catch调用
    - 结果对比:
        - 直接调用：交易完全回滚
        - try/catch调用：错误被捕获，主合约继续执行
        - 错误信息可存储在状态变量中

#### 4) try/catch 的无法捕获场景

- ![[f95123fdb773004cfa9dedbf15b1a0ec_MD5.jpg]]
- **风险预警**：
    1.  **调用非合约地址**：向空地址（无代码）发起调用将导致静默失败或直接报错，**不可被 try/catch 捕获**。
    2.  **Gas 耗尽**：属于系统级停堆，代码逻辑无法拦截。
- **建议**：在发起调用前，应使用 `extcodesize` 验证目标地址有效性。
**例题：合约调用错误验证**
    - ![[b0c29e00d617f8e5feb85b5436bff891_MD5.jpg]]
    - 测试方法:
        - 向非合约地址（0x5B3...eddC4）发起调用
        - 观察交易状态和Gas消耗
    - 结论验证:
        - 交易状态显示"errored"
        - 错误信息为"revert"
        - 证明此类错误无法被try/catch捕获


---

## 四、接口与继承 (Interfaces & Inheritance)

### 1. 接口 (Interfaces)

#### 1) 接口的定义及特性

- ![](https://bjbgp01.baidupcs.com/file/p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-1?bkt=en-3de6f374fcad9f514a94920d227b7f50&fid=282335-250528-&time=1767096414&sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-x5JsxnsVECqQxCikxB6fFPYNWuM%3D&to=75&size=10&sta_dx=10&sta_cs=0&sta_ft=&sta_ct=7&sta_mt=7&fm2=MH%2CBaoding%2CAnywhere%2C%2CNone%2Cany&ctime=0&mtime=0&dt3=0&resv0=-1&resv1=0&resv2=rlim&resv3=5&resv4=10&vuk=0&iv=2&vl=0&htype=&randtype=&newver=1&newfm=1&secfm=1&flow_ver=3&pkey=en-921e01a970812fd093172db84d5b5ca9942a99e920c580d3414cdcd25aa6165a3107730107948da19cee0c5c670c760046ef28a7e7e3edf6305a5e1275657320&expires=8h&r=890393342&vbdid=-&fin=p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-1&fn=p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-1&rtype=1&dp-logid=367983031159510226&dp-callid=0.1&hps=1&tsl=0&csl=0&fsl=-1&csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&so=0&ut=1&uter=-1&serv=-1&uc=256549726&ti=0cce998314b34a67afe4033e09cbfe863f37809100309786&hflag=30&from_type=&adg=n&reqlabel=250528_n_7bf4850e9a6fbe1b15855a0ec68f78c5_0_69218425c394759ca7e4387773d0582f&chkv=5&bid=250528&by=themis)
- **定义**：**接口**是只包含函数声明的类型，用于合约间解耦调用。
- **核心特性**：
    - **无实现**：仅声明函数签名，不能包含函数体。
    - **限制性**：不能继承其他合约或接口、无构造函数、无状态变量。
    - **抽象性**：相当于函数的抽象声明集合，类似于传统语言的 **Abstract Method**。
- **应用场景**：
    - 合约间解耦调用。
    - 标准化功能定义（如 **ERC20** 标准）。
    - 代码组织与复用。
    - ![](https://bjbgp01.baidupcs.com/file/p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-2?bkt=en-3de6f374fcad9f514a94920d227b7f50&fid=282335-250528-&time=1767096415&sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-TVv%2B8%2FvOpCWwILU%2FWtEcGjXdflk%3D&to=75&size=10&sta_dx=10&sta_cs=0&sta_ft=&sta_ct=7&sta_mt=7&fm2=MH%2CYangquan%2CAnywhere%2C%2CNone%2Cany&ctime=0&mtime=0&dt3=0&resv0=-1&resv1=0&resv2=rlim&resv3=5&resv4=10&vuk=0&iv=2&vl=0&htype=&randtype=&newver=1&newfm=1&secfm=1&flow_ver=3&pkey=en-59933f9e84e670504256f2344bbecaf89421707244d1a04f28baf6dcb96db400171b792659b885d9b9df93c3310b8437bc1622eacf9688f5305a5e1275657320&expires=8h&r=483446567&vbdid=-&fin=p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-2&fn=p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-2&rtype=1&dp-logid=367983031159510226&dp-callid=0.1&hps=1&tsl=0&csl=0&fsl=-1&csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&so=0&ut=1&uter=-1&serv=-1&uc=256549726&ti=5eee304bbb22b9c28caeb89191f7ef422125f8e5c6871b7d978956776b5d738c&hflag=30&from_type=&adg=n&reqlabel=250528_n_7bf4850e9a6fbe1b15855a0ec68f78c5_0_69218425c394759ca7e4387773d0582f&chkv=5&bid=250528&by=themis)
- **调用机制**：
    - 通过**函数选择器**（如 `0x4df...7e3d0`）准确定位目标函数。
    - 只需已知函数签名即可发起跨合约调用，无需依赖完整源代码。
    - 典型调用语法：`ICounter(_counter).increment()`。

### 2. 继承 (Inheritance)

#### 1) 继承的定义及特性

- ![](https://bjbgp01.baidupcs.com/file/p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-3?bkt=en-3de6f374fcad9f514a94920d227b7f50&fid=282335-250528-&time=1767096415&sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-vk5%2FEor1D19kLWZ%2FHmjlZo25Bfo%3D&to=75&size=10&sta_dx=10&sta_cs=0&sta_ft=&sta_ct=7&sta_mt=7&fm2=MH%2CBaoding%2CAnywhere%2C%2CNone%2Cany&ctime=0&mtime=0&dt3=0&resv0=-1&resv1=0&resv2=rlim&resv3=5&resv4=10&vuk=0&iv=2&vl=0&htype=&randtype=&newver=1&newfm=1&secfm=1&flow_ver=3&pkey=en-7dcee091d3bbc4c753be1e2b5303ebef9ff9df4b38f6bff25cba7178d0e9f83a79c3f0cc62072dcd7fddd354afa25f05aded2d1ca1d79678305a5e1275657320&expires=8h&r=114203769&vbdid=-&fin=p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-3&fn=p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-3&rtype=1&dp-logid=367983031159510226&dp-callid=0.1&hps=1&tsl=0&csl=0&fsl=-1&csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&so=0&ut=1&uter=-1&serv=-1&uc=256549726&ti=99f1bd1b53bcf330d04e54784f20945b2f848628fe52039b&hflag=30&from_type=&adg=n&reqlabel=250528_n_7bf4850e9a6fbe1b15855a0ec68f78c5_0_69218425c394759ca7e4387773d0582f&chkv=5&bid=250528&by=themis)
- **语法结构**：使用 `is` 关键字（如 `contract B is A`）。
- **编译特性**：
    - 基类代码在编译时会自动嵌入到派生合约中。
    - 链上仅部署最终生成的派生合约。
    - 基类的**状态变量**会按顺序占用派生合约的存储槽位置。
- **访问控制**：
    - 可访问父合约中所有非 `private` 成员。
    - `internal` 成员可被子合约直接引用。
    - `private` 变量虽然在链上实际占用存储空间，但对子合约逻辑不可见。
    - ![](https://bjbgp01.baidupcs.com/file/p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-4?bkt=en-3de6f374fcad9f514a94920d227b7f50&fid=282335-250528-&time=1767096415&sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-Y7Nja6Xy2%2FBLMl6iDyT6KopoIkE%3D&to=75&size=10&sta_dx=10&sta_cs=0&sta_ft=&sta_ct=7&sta_mt=7&fm2=MH%2CBaoding%2CAnywhere%2C%2CNone%2Cany&ctime=0&mtime=0&dt3=0&resv0=-1&resv1=0&resv2=rlim&resv3=5&resv4=10&vuk=0&iv=2&vl=0&htype=&randtype=&newver=1&newfm=1&secfm=1&flow_ver=3&pkey=en-96bbd21d873752f8b443f9aa79a1f8812f4046570a533520300f2ff469969f6f14c908f16c5ffe752ac512841d23fa2df5c51ec6f0c3b764305a5e1275657320&expires=8h&r=929382113&vbdid=-&fin=p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-4&fn=p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-4&rtype=1&dp-logid=367983031159510226&dp-callid=0.1&hps=1&tsl=0&csl=0&fsl=-1&csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&so=0&ut=1&uter=-1&serv=-1&uc=256549726&ti=5eee304bbb22b9c262e485b8428e5c1766062e68e1930e27305a5e1275657320&hflag=30&from_type=&adg=n&reqlabel=250528_n_7bf4850e9a6fbe1b15855a0ec68f78c5_0_69218425c394759ca7e4387773d0582f&chkv=5&bid=250528&by=themis)
- **存储特点**：
    - **私有变量**（`private`）仍会在合约存储中分配空间。
    - 开发者可通过底层的 **RPC** 方法（如 `eth_getStorageAt`）直接读取这些敏感数据。
    - 安全提醒：在派生合约中，私有变量虽不可见，但其物理存储实际上一直伴随。

### 3. 抽象合约 (Abstract Contracts)

#### 1) 抽象合约特性

- ![](https://bjbgp01.baidupcs.com/file/p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-5?bkt=en-3de6f374fcad9f514a94920d227b7f50&fid=282335-250528-&time=1767096415&sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-IDN%2F%2BvP5TxKFQOGghVGs96DxG44%3D&to=75&size=10&sta_dx=10&sta_cs=0&sta_ft=&sta_ct=7&sta_mt=7&fm2=MH%2CYangquan%2CAnywhere%2C%2CNone%2Cany&ctime=0&mtime=0&dt3=0&resv0=-1&resv1=0&resv2=rlim&resv3=5&resv4=10&vuk=0&iv=2&vl=0&htype=&randtype=&newver=1&newfm=1&secfm=1&flow_ver=3&pkey=en-b16f7a87b095a2dff90b4a2b74ef1ba4f878bfec0e3dfd2cc68b0f8ae6b7b834279c89b0e47ffe29ed234a5b159028be43619dfba4673354305a5e1275657320&expires=8h&r=540182422&vbdid=-&fin=p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-5&fn=p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-5&rtype=1&dp-logid=367983031159510226&dp-callid=0.1&hps=1&tsl=0&csl=0&fsl=-1&csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&so=0&ut=1&uter=-1&serv=-1&uc=256549726&ti=e83ff6a139489830f86b48b6506bb92c49ae27151a4621eb&hflag=30&from_type=&adg=n&reqlabel=250528_n_7bf4850e9a6fbe1b15855a0ec68f78c5_0_69218425c394759ca7e4387773d0582f&chkv=5&bid=250528&by=themis)
- **核心特征**：
    - 使用 `abstract` 关键字声明。
    - 允许包含未实现的纯虚函数。
    - **不能被直接部署**，必须被子合约继承实现。
- **关键修辞符**：
    - `virtual`：在父合约中标记可被子合约重写的函数。
    - `override`：在子合约中明确声明重写父合约中的同名函数。
    - `super`：用于显式调用父合约的已有实现（如 `super.add(b)`）。
    - ![](https://bjbgp01.baidupcs.com/file/p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-6?bkt=en-3de6f374fcad9f514a94920d227b7f50&fid=282335-250528-&time=1767096415&sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-M1MFcz%2BWMCyhkb%2Bm3JulFeEDGSk%3D&to=75&size=10&sta_dx=10&sta_cs=0&sta_ft=&sta_ct=7&sta_mt=7&fm2=MH%2CBaoding%2CAnywhere%2C%2CNone%2Cany&ctime=0&mtime=0&dt3=0&resv0=-1&resv1=0&resv2=rlim&resv3=5&resv4=10&vuk=0&iv=2&vl=0&htype=&randtype=&newver=1&newfm=1&secfm=1&flow_ver=3&pkey=en-6ec96353ac059a6ea2fcdad4d9554feba5d601a62ee1b6fdf62da06aa41e9fbbd3769b12bbbb3fcde91eb626c027215e9f2fae5f8d519a18305a5e1275657320&expires=8h&r=211582691&vbdid=-&fin=p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-6&fn=p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-6&rtype=1&dp-logid=367983031159510226&dp-callid=0.1&hps=1&tsl=0&csl=0&fsl=-1&csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&so=0&ut=1&uter=-1&serv=-1&uc=256549726&ti=5eee304bbb22b9c2311f56e3d63480cb66062e68e1930e27305a5e1275657320&hflag=30&from_type=&adg=n&reqlabel=250528_n_7bf4850e9a6fbe1b15855a0ec68f78c5_0_69218425c394759ca7e4387773d0582f&chkv=5&bid=250528&by=themis)
- **重写规则**：
    - 未明确标记 `virtual` 的函数严禁被子合约重写。
    - 执行重写操作时，必须携带 `override` 声明。
    - 在承接**多重继承**时，若同名函数存在于多个父合约中，重写时需显式列出所有路径。

---

## 五、实践作业 (Hands-on Practice)

- ![](https://bjbgp01.baidupcs.com/file/p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-7?bkt=en-3de6f374fcad9f514a94920d227b7f50&fid=282335-250528-&time=1767096415&sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-1Ke%2BkwSEQBlqHtmmzBSUCaBxqoE%3D&to=75&size=10&sta_dx=10&sta_cs=0&sta_ft=&sta_ct=7&sta_mt=7&fm2=MH%2CXian%2CAnywhere%2C%2CNone%2Cany&ctime=0&mtime=0&dt3=0&resv0=-1&resv1=0&resv2=rlim&resv3=5&resv4=10&vuk=0&iv=2&vl=0&htype=&randtype=&newver=1&newfm=1&secfm=1&flow_ver=3&pkey=en-d1a40d3b68d8846021709d75235554e1ec0154d25ec97007aeb70fb97080a6bf1de9f17736730ab503088a019d6ec4e9fac3d1f7de33dbb9305a5e1275657320&expires=8h&r=482395964&vbdid=-&fin=p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-7&fn=p-8622d1f7523b1f856984e03c4474e44c-40-2025042100-7&rtype=1&dp-logid=367983031159510226&dp-callid=0.1&hps=1&tsl=0&csl=0&fsl=-1&csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&so=0&ut=1&uter=-1&serv=-1&uc=256549726&ti=e83ff6a1394898306176db7106b117e549ae27151a4621eb&hflag=30&from_type=&adg=n&reqlabel=250528_n_7bf4850e9a6fbe1b15855a0ec68f78c5_0_69218425c394759ca7e4387773d0582f&chkv=5&bid=250528&by=themis)
- **实现要求**：
    - 继承 `Bank` 合约实现 `BigBank`。
    - 使用 `modifier` 限制存款金额（必须 `> 0.001 ETH`）。
    - 引入 `Admin` 合约管理最终资金的提取。
- **技术要点**：
    - 合约间底层的调用模式（**Interface Call**）。
    - **ACL**（访问控制列表）的严谨实现。
    - 企业级资金托管架构的设计思路。

---


## 六、合约接口描述与编码 (ABI & Encoding)

### 1. 合约调用过程

- ![](https://bjbgp01.baidupcs.com/file/p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-2?bkt=en-3de6f374fcad9f514a94920d227b7f50&fid=282335-250528-&time=1767102299&sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-3rers%2BaUYYw5A1Fx%2FFkdKA3K4uU%3D&to=75&size=10&sta_dx=10&sta_cs=0&sta_ft=&sta_ct=7&sta_mt=7&fm2=MH%2CBaoding%2CAnywhere%2C%2CNone%2Cany&ctime=0&mtime=0&dt3=0&resv0=-1&resv1=0&resv2=rlim&resv3=5&resv4=10&vuk=0&iv=2&vl=0&htype=&randtype=&newver=1&newfm=1&secfm=1&flow_ver=3&pkey=en-f5a0e2f95d580def60e4981524961c90ff37c2e82d64574f5b7e22eddb7ec31fb702a1269d12ccf53db2f93a09601583ceba668dec21c1b4305a5e1275657320&expires=8h&r=502293994&vbdid=-&fin=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-2&fn=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-2&rtype=1&dp-logid=369562531525339941&dp-callid=0.1&hps=1&tsl=0&csl=0&fsl=-1&csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&so=0&ut=1&uter=-1&serv=-1&uc=256549726&ti=4126a8bea2f5ff03d74e435d9688b86827fd2b7c4479c4d6&hflag=30&from_type=&adg=n&reqlabel=250528_n_7bf4850e9a6fbe1b15855a0ec68f78c5_0_69218425c394759ca7e4387773d0582f&chkv=5&bid=250528&by=themis)
- **交易结构**：
    - **普通交易**：包含 **to** 地址、**value** 和 **data** 字段。
    - **创建合约**：**to** 字段为空地址，**data** 字段包含完整的合约字节码。
    - **调用合约**：**to** 为目标合约地址，**data** 字段包含对应函数的 **ABI** 编码。
- **调用本质**：所有合约调用最终都转化为向合约地址发送 **ABI** 编码数据的交易。

### 2. ABI (Application Binary Interface)

#### 1) ABI 接口描述

- ![](https://bjbgp01.baidupcs.com/file/p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-3?bkt=en-3de6f374fcad9f514a94920d227b7f50&fid=282335-250528-&time=1767102299&sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-Od8AO3xFsLhSflvBRL5OUZPsaPU%3D&to=75&size=10&sta_dx=10&sta_cs=0&sta_ft=&sta_ct=7&sta_mt=7&fm2=MH%2CBaoding%2CAnywhere%2C%2CNone%2Cany&ctime=0&mtime=0&dt3=0&resv0=-1&resv1=0&resv2=rlim&resv3=5&resv4=10&vuk=0&iv=2&vl=0&htype=&randtype=&newver=1&newfm=1&secfm=1&flow_ver=3&pkey=en-c47f15e5c36d8aa8b4ffa37b0de9859ab33b51399a888f58269037b51b3f656bb6fe4cc5d4e6be8a72e1b3050f564fb927023b726cc2caf9305a5e1275657320&expires=8h&r=752022814&vbdid=-&fin=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-3&fn=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-3&rtype=1&dp-logid=369562531525339941&dp-callid=0.1&hps=1&tsl=0&csl=0&fsl=-1&csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&so=0&ut=1&uter=-1&serv=-1&uc=256549726&ti=66239664855e806891acaf3585bb2d5848a681f1cec83533a6c2ad6eeb587c84&hflag=30&from_type=&adg=n&reqlabel=250528_n_7bf4850e9a6fbe1b15855a0ec68f78c5_0_69218425c394759ca7e4387773d0582f&chkv=5&bid=250528&by=themis)
- **作用**：定义如何与智能合约交互的标准接口规范。
- **生成方式**：由编译器在编译时自动生成 **JSON** 格式的描述文件。
- **必要性**：由于字节码无法直接反映合约逻辑接口，因此通过 **ABI** 元数据系统进行桥接。

#### 2) 函数选择器 (Function Selector)

- ![](https://bjbgp01.baidupcs.com/file/p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-4?bkt=en-3de6f374fcad9f514a94920d227b7f50&fid=282335-250528-&time=1767102299&sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-Dd%2F6Ne1rTNeFOhmRVL9uHcbcYjA%3D&to=75&size=10&sta_dx=10&sta_cs=0&sta_ft=&sta_ct=7&sta_mt=7&fm2=MH%2CBaoding%2CAnywhere%2C%2CNone%2Cany&ctime=0&mtime=0&dt3=0&resv0=-1&resv1=0&resv2=rlim&resv3=5&resv4=10&vuk=0&iv=2&vl=0&htype=&randtype=&newver=1&newfm=1&secfm=1&flow_ver=3&pkey=en-cc2b53103bf1f54831bb57dd03de93603bc487065d2692ca1e526a27c0dddd7224753c2ed0752721777f2fdf5ab025321ca7c3fb9d01234c305a5e1275657320&expires=8h&r=978935408&vbdid=-&fin=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-4&fn=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-4&rtype=1&dp-logid=369562531525339941&dp-callid=0.1&hps=1&tsl=0&csl=0&fsl=-1&csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&so=0&ut=1&uter=-1&serv=-1&uc=256549726&ti=24f48e7bb37b52f0cc0df9725792f67f27fd2b7c4479c4d6&hflag=30&from_type=&adg=n&reqlabel=250528_n_7bf4850e9a6fbe1b15855a0ec68f78c5_0_69218425c394759ca7e4387773d0582f&chkv=5&bid=250528&by=themis)
- **计算方法**：对“函数签名”进行 **Keccak-256** 哈希运算，并截取结果的前 **4** 个字节。
    - 示例：`count()` → `keccak256("count()")` → **0x06661abd**。
- **特性**：
    - **忽略变量名**：仅关注函数名及其参数类型列表。
    - **类型扩展**：基本类型在哈希前会扩展为完整形式（例如 `uint` 会被视为 `uint256`）。
- **获取途径**：
    - 使用在线工具（如 **Keccak-256** 在线生成器）。
    - 访问 **4byte.directory** 签名数据库进行公开查询。
    - 在 **Solidity** 中通过 `abi.encodeWithSignature` 或 `.selector` 成员直接获取。

#### 3) 参数编码 (Argument Encoding)

- ![](https://bjbgp01.baidupcs.com/file/p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-5?bkt=en-3de6f374fcad9f514a94920d227b7f50&fid=282335-250528-&time=1767102299&sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-lqtKO4UhVGwGGKSQVok77Abjt4c%3D&to=75&size=10&sta_dx=10&sta_cs=0&sta_ft=&sta_ct=7&sta_mt=7&fm2=MH%2CBaoding%2CAnywhere%2C%2CNone%2Cany&ctime=0&mtime=0&dt3=0&resv0=-1&resv1=0&resv2=rlim&resv3=5&resv4=10&vuk=0&iv=2&vl=0&htype=&randtype=&newver=1&newfm=1&secfm=1&flow_ver=3&pkey=en-52b6534003704c9fecb44a362f21c66adf31fb02f16b04f345af848639567fce7123e19bee770624e07e98cd2fa90030a38e2cb313de0cdc305a5e1275657320&expires=8h&r=969334843&vbdid=-&fin=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-5&fn=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-5&rtype=1&dp-logid=369562531525339941&dp-callid=0.1&hps=1&tsl=0&csl=0&fsl=-1&csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&so=0&ut=1&uter=-1&serv=-1&uc=256549726&ti=66239664855e8068230408e99c62dfff6fe05388c330e61d305a5e1275657320&hflag=30&from_type=&adg=n&reqlabel=250528_n_7bf4850e9a6fbe1b15855a0ec68f78c5_0_69218425c394759ca7e4387773d0582f&chkv=5&bid=250528&by=themis)
- **编码规则**：
    - 参数会被扩展为 **32 字节**（**256 bits**）对齐的格式。
    - 示例：`set(10)` 调用产生的交易 **data** 为：`0x60fe47b1` (选择器) + `000...000a` (参数 **10** 经过 32 字节填充)。
- **注意事项**：
    - 参数编码顺序必须与函数签名保持严格一致。
    - 动态类型（如 `string`, `bytes`, 动态数组）涉及复杂的偏移量编码机制。

#### 4) 智能合约调用全流程

- ![](https://bjbgp01.baidupcs.com/file/p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-6?bkt=en-3de6f374fcad9f514a94920d227b7f50&fid=282335-250528-&time=1767102299&sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-ZlmWETFwQBP37FW4mCtfn1ai1LY%3D&to=75&size=10&sta_dx=10&sta_cs=0&sta_ft=&sta_ct=7&sta_mt=7&fm2=MH%2CBaoding%2CAnywhere%2C%2CNone%2Cany&ctime=0&mtime=0&dt3=0&resv0=-1&resv1=0&resv2=rlim&resv3=5&resv4=10&vuk=0&iv=2&vl=0&htype=&randtype=&newver=1&newfm=1&secfm=1&flow_ver=3&pkey=en-0c3d1a67e219b6f72b211188ac43f497c77a152c06a3d024607b984a5d722f5c35eebb76f1ebb0720961afc8b5cf8cf2e0620ebca98f13c8305a5e1275657320&expires=8h&r=144879799&vbdid=-&fin=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-6&fn=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-6&rtype=1&dp-logid=369562531525339941&dp-callid=0.1&hps=1&tsl=0&csl=0&fsl=-1&csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&so=0&ut=1&uter=-1&serv=-1&uc=256549726&ti=bdce10ad9517bbeb68a576e80f863c9427fd2b7c4479c4d6&hflag=30&from_type=&adg=n&reqlabel=250528_n_7bf4850e9a6fbe1b15855a0ec68f78c5_0_69218425c394759ca7e4387773d0582f&chkv=5&bid=250528&by=themis)
- **完整交互逻辑**：
    1.  将函数名与参数类型列表转换为 **HEX** 格式的 **ABI** 编码数据。
    2.  构造一个标准的交易对象（包含目标地址 **to**、转移币种 **value**、业务数据 **data**）。
    3.  使用该交易发起者的私钥进行加密签名。
    4.  通过节点将签名后的交易广播发送至以太坊网络。
- **节点执行机制**：节点在成功验证签名后，根据交易中的 **data** 片段（即 **ABI** 编码），在 EVM 内部匹配并触发对应的合约逻辑。

#### 5) Ethereum Signature Database (签名数据库)

- ![](https://bjbgp01.baidupcs.com/file/p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-7?bkt=en-3de6f374fcad9f514a94920d227b7f50&fid=282335-250528-&time=1767102299&sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-%2BHhm8hhoUHGJxzX5Kt25T1RBvfg%3D&to=75&size=10&sta_dx=10&sta_dx=10&sta_cs=0&sta_ft=&sta_ct=7&sta_mt=7&fm2=MH%2CBaoding%2CAnywhere%2C%2CNone%2Cany&ctime=0&mtime=0&dt3=0&resv0=-1&resv1=0&resv2=rlim&resv3=5&resv4=10&vuk=0&iv=2&vl=0&htype=&randtype=&newver=1&newfm=1&secfm=1&flow_ver=3&pkey=en-518f106b80d3a81eeb8aa8f53342423ec53c98a55279cf0509c6424940bc0c2cda7ae4064ae8eb542e727ed4ccd722dbac84ce2856ec2c44305a5e1275657320&expires=8h&r=666907555&vbdid=-&fin=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-7&fn=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-7&rtype=1&dp-logid=369562531525339941&dp-callid=0.1&hps=1&tsl=0&csl=0&fsl=-1&csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&so=0&ut=1&uter=-1&serv=-1&uc=256549726&ti=66239664855e80689ceadc16fe65114048a681f1cec83533a6c2ad6eeb587c84&hflag=30&from_type=&adg=n&reqlabel=250528_n_7bf4850e9a6fbe1b15855a0ec68f78c5_0_69218425c394759ca7e4387773d0582f&chkv=5&bid=250528&by=themis)
- **作用**：通过**函数选择器**（**HEX**）反向查询对应的原始**函数签名**。
- **特点**：目前包含超过 **130 万** 条公开的函数签名映射记录。
- **使用场景**：在分析未知合约或反编译合约代码时，用于确定具体的函数调用意图。

#### 6) 应用案例解析

- **例题：函数选择器获取示例**
    - ![](https://bjbgp01.baidupcs.com/file/p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-8?bkt=en-3de6f374fcad9f514a94920d227b7f50&fid=282335-250528-&time=1767102299&sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-WCbi29I4q96E9iyG9VXz9q%2BHRP8%3D&to=75&size=10&sta_dx=10&sta_cs=0&sta_ft=&sta_ct=7&sta_mt=7&fm2=MH%2CBaoding%2CAnywhere%2C%2CNone%2Cany&ctime=0&mtime=0&dt3=0&resv0=-1&resv1=0&resv2=rlim&resv3=5&resv4=10&vuk=0&iv=2&vl=0&htype=&randtype=&newver=1&newfm=1&secfm=1&flow_ver=3&pkey=en-1e5a5d2ddf3ebc28a33d4774290cc456d1813f5a379dffeda6ee16dca51aee5bd0426220b71ee64a9e7f793a1313fd78ce4621f213b75fb4305a5e1275657320&expires=8h&r=224207022&vbdid=-&fin=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-8&fn=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-8&rtype=1&dp-logid=369562531525339941&dp-callid=0.1&hps=1&tsl=0&csl=0&fsl=-1&csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&so=0&ut=1&uter=-1&serv=-1&uc=256549726&ti=058e25ce645ae596960ae26d525c48ff27fd2b7c4479c4d6&hflag=30&from_type=&adg=n&reqlabel=250528_n_7bf4850e9a6fbe1b15855a0ec68f78c5_0_69218425c394759ca7e4387773d0582f&chkv=5&bid=250528&by=themis)
    - **题目解析**：
        - 计算 `count()` 的函数选择器。
        - 使用 **Keccak-256** 在线工具进行哈希验证。
        - **答案**：`0x06661abd`。
- **例题：直接 ABI 编码调用合约函数示例**
    - ![](https://bjbgp01.baidupcs.com/file/p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-9?bkt=en-3de6f374fcad9f514a94920d227b7f50&fid=282335-250528-&time=1767102299&sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-XAL40VjiND2X%2B95FsbIeESRr2%2FY%3D&to=75&size=10&sta_dx=10&sta_cs=0&sta_ft=&sta_ct=7&sta_mt=7&fm2=MH%2CBaoding%2CAnywhere%2C%2CNone%2Cany&ctime=0&mtime=0&dt3=0&resv0=-1&resv1=0&resv2=rlim&resv3=5&resv4=10&vuk=0&iv=2&vl=0&htype=&randtype=&newver=1&newfm=1&secfm=1&flow_ver=3&pkey=en-338fb88d7f2ff0c439e2b1e1f1c1c1255f5b8d64ace14196639dc13332533347ad51c12a8a5484691c63e466d6ad7b8c15c119cfba040b97305a5e1275657320&expires=8h&r=681528582&vbdid=-&fin=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-9&fn=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-9&rtype=1&dp-logid=369562531525339941&dp-callid=0.1&hps=1&tsl=0&csl=0&fsl=-1&csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&so=0&ut=1&uter=-1&serv=-1&uc=256549726&ti=6a9088c7620f7a17628d4364da4e7bb127fd2b7c4479c4d6&hflag=30&from_type=&adg=n&reqlabel=250528_n_7bf4850e9a6fbe1b15855a0ec68f78c5_0_69218425c394759ca7e4387773d0582f&chkv=5&bid=250528&by=themis)
    - **题目解析**：
        - 对比常规调用模式与底层 `call` 调用模式。
        - 演示 `abi.encodeWithSignature` 在合约交互中的实际作用。
        - **答案**：两种方式底层效果一致，但语义化与安全性程度不同。

### 3. 底层调用函数 (Low-level Calls)

- ![](https://bjbgp01.baidupcs.com/file/p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-10?bkt=en-3de6f374fcad9f514a94920d227b7f50&fid=282335-250528-&time=1767102299&sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-fil6WChNG2EpYtY8nb%2FaHs%2B1dCk%3D&to=75&size=10&sta_dx=10&sta_cs=0&sta_ft=&sta_ct=7&sta_mt=7&fm2=MH%2CBaoding%2CAnywhere%2C%2CNone%2Cany&ctime=0&mtime=0&dt3=0&resv0=-1&resv1=0&resv2=rlim&resv3=5&resv4=10&vuk=0&iv=2&vl=0&htype=&randtype=&newver=1&newfm=1&secfm=1&flow_ver=3&pkey=en-56c57337da88bceed9ae723552690189cefa82b685ffa31099352547d17da85c981296e4d4c96730f428cfe2fefc4420db3f992bf39307c1305a5e1275657320&expires=8h&r=729710686&vbdid=-&fin=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-10&fn=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-10&rtype=1&dp-logid=369562531525339941&dp-callid=0.1&hps=1&tsl=0&csl=0&fsl=-1&csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&so=0&ut=1&uter=-1&serv=-1&uc=256549726&ti=058e25ce645ae596f29f5430320510446fe05388c330e61d305a5e1275657320&hflag=30&from_type=&adg=n&reqlabel=250528_n_7bf4850e9a6fbe1b15855a0ec68f78c5_0_69218425c394759ca7e4387773d0582f&chkv=5&bid=250528&by=themis)
- **语法形式**：`<address>.call(bytes memory) returns (bool, bytes memory)`
- **核心特点**：
    - **手动返回值处理**：必须手动接收并检查返回的 `bool` 值（表示交易执行是否成功）。
    - **永不触发回滚**：即使被调用函数失败，底层 `call` 也不会抛出异常，仅返回 `false`。
    - **高灵活性/低安全性**：适用于动态交互场景，但若缺乏严格检查，极易引发安全漏洞。
- **例题：计数器合约多维调用案例**
    - ![](https://bjbgp01.baidupcs.com/file/p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-11?bkt=en-3de6f374fcad9f514a94920d227b7f50&fid=282335-250528-&time=1767102300&sign=FDTAXUVGEQlBHSKfWqij-GBWOGYTBgG0KqHy7wNbwoLTVMyJyK6xE-%2BLTjiF3uNvrzhQWEj0tgXgNyU94%3D&to=75&size=10&sta_dx=10&sta_cs=0&sta_ft=&sta_ct=7&sta_mt=7&fm2=MH%2CBaoding%2CAnywhere%2C%2CNone%2Cany&ctime=0&mtime=0&dt3=0&resv0=-1&resv1=0&resv2=rlim&resv3=5&resv4=10&vuk=0&iv=2&vl=0&htype=&randtype=&newver=1&newfm=1&secfm=1&flow_ver=3&pkey=en-f2bbe292de566364e24bf8b1a1123e7cb168422e2a2092c30e7b9d13d72209a52eee9f066c39c188d2ef6899bfdff1938d060c3f2c9147c9305a5e1275657320&expires=8h&r=769336909&vbdid=-&fin=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-11&fn=p-d4043b41c93a6a097dc9455b1f797b4b-40-2025042100-11&rtype=1&dp-logid=369562531525339941&dp-callid=0.1&hps=1&tsl=0&csl=0&fsl=-1&csign=dmayhhcqdS1jXSxjkf6DN1P7N8o%3D&so=0&ut=1&uter=-1&serv=-1&uc=256549726&ti=c77a2290e27174be1f9fb8d325cacafa6fe05388c330e61d305a5e1275657320&hflag=30&from_type=&adg=n&reqlabel=250528_n_7bf4850e9a6fbe1b15855a0ec68f78c5_0_69218425c394759ca7e4387773d0582f&chkv=5&bid=250528&by=themis)
    - **题目解析**：
        - 演示合约类型直接调用、**Interface** 实例化调用以及底层 `call` 调用。
        - 三种方式逻辑上均可实现计数器的递增操作。
        - **答案**：功能最终等效，但从代码健壮性角度，安全级别与其顺序成正比。

---





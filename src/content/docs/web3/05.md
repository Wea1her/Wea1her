---
title: "05"
description: ""
order: 5
---


#### 一、函数调用﻿00:15﻿

##### 1. 调用结果﻿00:30﻿

- ![[31f561d74002f34768bc0fd60fda2540_MD5.jpg]]
- 接口调用与底层调用:
    - 接口调用: 通过合约类型实例直接调用方法，如c.count()
    - 底层调用: 使用address.call()和ABI编码调用，如abi.encodeWithSignature("count()")
    - 调用结果等价性: 两种方式最终都会转换为对合约函数的ABI编码调用
- ABI编码组成:
    - 函数选择器: 对函数签名计算
        
        ﻿Keccak−256\mathrm{Keccak}-256Keccak−256﻿
        
        哈希，取前4个字节
    - 参数编码: 包含函数参数的编码数据
- 安全性对比:
    - 接口调用优势: 自动检查合约存在性、函数返回值和参数，调用失败会直接revert
    - 底层调用注意点: 需要手动检查返回值、调用状态和返回数据

##### 2. 转账﻿01:48﻿

- ![[c9c5531ee0b832b04dd3c84e28fd5539_MD5.jpg]]
- 传统转账方法:
    - transfer: 固定2300 gas限制，合约接收容易失败
    - send: 同样受2300 gas限制，返回布尔值需手动检查
- 底层调用转账:
    - call方法优势: 无gas限制或可手动指定gas量
    - 语法示例:
        - addr.call{gas: 1000000}(new bytes(0))
        - addr.call{value: 1 ether}(new bytes(0))
- OpenZeppelin实践:
    - sendValue实现: 替代transfer，转发所有可用gas，失败时revert
    - 安全考虑: 需防范重入攻击，建议配合ReentrancyGuard使用

##### 3. 三种交易﻿02:40﻿

- ![[7521bdb182c75d54eaf8b3402ba81e7f_MD5.jpg]]
- 普通转账交易:
    - 特征: data字段为空，仅包含value转账金额
- 合约创建交易:
    - 特征: to地址为零，data字段包含合约创建字节码
- 合约调用交易:
    - 特征: 包含合约地址和ABI编码的调用数据

##### 4. 应用案例﻿03:55﻿

###### 1）例题:转账示例题

- ![[b77578c7cf7f27396d75b3bdf6e2b7a8_MD5.jpg]]
- 题目解析:
    - 传统transfer限制: 演示中因2300 gas不足导致转账失败
    - call方法成功原因: 不受gas限制，可执行合约receive函数中的逻辑
    - OpenZeppelin最佳实践: 推荐使用sendValue而非手动实现call转账

###### 2）例题:转账测试地址示例题﻿04:40﻿

- ![[74e0a7b6819ee8a7101cf9e07a21926a_MD5.jpg]]
- 题目解析:
    - 测试环境搭建:
        - 部署testAddr合约并预存10 ETH
        - 部署testPayable合约作为接收方
    - 关键观察点:
        - transfer调用因gas限制失败
        - call调用成功执行receive函数并更新状态变量
    - gas消耗分析:
        - 成功交易消耗约8万gas
        - 包含状态变量更新和完整函数执行

#### 二、底层调用﻿07:40﻿

##### 1. 底层函数类型

- ![[fddd06aa6b6533d5a872d196b919f147_MD5.jpg]]
- call函数:
    - 上下文切换: 会切换执行上下文，msg.sender变为调用者合约地址
    - 异常处理: 调用失败不会抛出异常(revert)，而是通过返回值表示
- delegatecall函数:
    - 上下文保持: 保持当前执行上下文，msg.sender保持为原始调用者地址
    - 状态修改: 被调用合约代码在调用者合约上下文中执行，修改的是调用者合约的状态变量
- staticcall函数:
    - 只读特性: 不修改状态，相当于模拟调用
    - 适用场景: 主要用于查询操作

##### 2. 调用上下文对比

- ![[fe46faee5b6e06c5c7bd3beadf4e74af_MD5.jpg]]
- call调用链:
    - EOA → Caller合约 → Target合约
    - msg.sender变化: EOA地址 → Caller合约地址
    - msg.value变化: EOA发送值 → Caller发送值
- delegatecall调用链:
    - EOA → Caller合约 → Target合约
    - msg.sender保持: 始终为EOA地址
    - msg.value保持: 始终为EOA发送值

##### 3. 代码示例分析

- ![[ad362471e84ae356990eddc1079f4fab_MD5.jpg]]
- call示例:
    - 被调用合约的counter和sender状态变量会被修改
    - 调用链形成完整上下文切换
- delegatecall示例:
    - 调用者合约的counter和sender状态变量会被修改
    - 相当于"借用"目标合约代码在当前合约上下文中执行

##### 4. 实际调用演示

- ![[26e0cbc44b5c260a0483b08ba9c6b19b_MD5.jpg]]
- call调用结果:
    - 被调用合约状态变量更新
    - sender显示为中间调用合约地址
- delegatecall调用结果:
    - 调用者合约状态变量更新
    - sender显示为原始EOA地址
    - 被调用合约状态保持不变

##### 5. 异常处理机制

- 异常处理特点:
    - 底层调用失败不会自动revert整个交易
    - 通过返回的bool值表示调用成功与否
    - 需要手动检查返回值处理失败情况
- 与高级调用的区别:
    - 普通函数调用失败会冒泡异常
    - 底层调用需要显式错误处理

##### 6. 地址功能小结﻿14:05﻿

- ![[56ce2edcd2a16274548fd49fe69fdf51_MD5.jpg]]
- 基本属性:
    - balance: 查询地址ETH余额
    - transfer()/send(): ETH转账方法
        - transfer: 失败会revert，gas限制2300
        - send: 失败返回false，gas限制2300
- 底层调用:
    - call: 切换上下文，可附带ETH和价值
    - delegatecall: 保持上下文，常用于代理模式
    - staticcall: 只读调用，不修改状态
- 共同特点:
    - 调用失败不自动revert
    - 通过返回值(bool)表示调用结果
    - 需要手动处理调用失败情况

#### 三、知识小结

|   |   |   |   |
|---|---|---|---|
|知识点|核心内容|考试重点/易混淆点|难度系数|
|ABI底层调用|函数调用转换为ABI编码调用，包含函数选择器和参数编码|接口调用与底层call调用的区别|⭐⭐⭐|
|安全调用方式|使用接口或合约类型调用更安全，会自动检查合约存在性、参数和返回值|调用失败时自动回滚 vs 需要手动检查返回值|⭐⭐|
|转账方法对比|transfer受2300gas限制 vs sendValue不受gas限制|合约接收转账时receive函数可能因gas不足失败|⭐⭐⭐⭐|
|call底层调用|会切换执行上下文，message.sender变为调用合约地址|调用失败不会回滚交易，需检查返回值|⭐⭐⭐|
|delegateCall|保持调用上下文，相当于借用目标合约代码在当前合约执行|修改的是调用合约的状态变量|⭐⭐⭐⭐|
|staticCall|模拟调用(dry run)，不会修改状态|主要用于只读操作验证|⭐⭐|
|地址成员属性|balance/transfer/send/call/delegateCall/staticCall|不同调用方式的gas处理机制差异|⭐⭐⭐|
|上下文保持|delegateCall保持原始msg.sender和存储上下文|与普通call的上下文切换对比|⭐⭐⭐⭐|
|失败处理机制|高级调用自动回滚 vs 底层调用返回bool状态|错误处理策略选择|⭐⭐⭐|